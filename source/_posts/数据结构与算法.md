---
title: 数据结构与算法
date: 2024-07-29 09:12:46
tags: 数据结构 算法
categories: 听课笔记
---

# 绪论

## **数据结构在学什么？**      

如何使用数据来表示生活中的问题.

## 数据结构的基本概念

![](数据元素和数据项.png)

**数据**：数据是{%label 信息的载体 green%}，是描述客观事物属性的数，字符及所有能输入到计算机中{%label 并被计算机程序识别和处理 green%}的符号的集合。数据是计算机程序加工的原料。

**数据元素**：是数据的{%label 基本单位 green%}，通常作为一个整体进行考虑和处理。一个数据元素可由若干{%label 数据项 green%}组成，数据项是构成数据元素的不可分割的最小单位。

![](数据对象.png)

**数据对象**:具有{%label 相同性质 green%}的数据元素的集合，是数据的一个子集。

**数据结构**:相互之间存在一种或多种{%label 特定关系 green%}的数据元素的集合。

**数据类型**：一个值的集合和定义在此集合上的一组操作的总称。

- 原子类型：其值不可再分的数据类型，如bool类型，int类型
- 结构类型：其值可以再分解为若干成分(分量)的数据类型

```cpp
struct Coordinate {
    int x;
    int y;
}
```

**抽象数据类型**(Abstract Data Type,ADT): 是抽象数据组织及与之相关的操作.

## 数据结构的三要素

### 逻辑结构

**集合**：各个元素同属于一个集合，并无其他关系

**线性结构**：数据元素之间是{%label 一对一的关系 green%}的关系。除了第一个元素，都有一个唯一的前驱。除了最后一个元素，所有的元素都有唯一后继。

**树形结构**：数据元素之间的{%label 一对多 green%}的关系。

**图结构**:数据元素之间是{%label 多对多的关系 green%}

### 数据的运算

结合逻辑结构，实际需求来定义基本运算。

### 物理结构(存储结构)

如何用计算机实现这种数据结构

- 顺序存储：把{%label 逻辑上相邻的元素存储在物理位置上也相邻的存储单元中 green%}，元素之间的关系由存储单元的邻接关系来体现。
- 链式存储：{%label 逻辑上相邻的元素在物理位置上可以不相邻 green%}，借助指数元素存储地址的指针来表示元素之间的逻辑关系。
- 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为{%label 索引项 green%}，索引项的一般形式是{%label (关键字，地址) green%}
- 散列存储(Hash存储): 根据元素的关键字直接计算出该元素的存储地址。

>运算的定义是针对逻辑结构的，指出运算的功能。
>
>运算的实现是针对存储结构的，指出运算的具体操作步骤。



## 算法的基本概念

**算法**(Algorithm):对{%label 特定问题求解步骤的一种描述 green%},它是指令的有限序列,其中每条指令表示一个或多个操作.

**算法的特性**:

- 有穷性:一个算法必须总在执行有穷步之后结束,且每一步都可在又穷时间内完成.
- 确定性:算法中每条指令必须有确切的含义,对于{%label 相同的输入 green%}只能得到{%label 相同的输出 green%}.
- 可行性:算法中描述的操作都可以通过已经实现的{%label 基本运算执行有限次 green%}来实现.
- 输入:一个算法有{%label 零个或多个输入 green%},这些输入取自于某个特定的对象的集合.
- 输出:一个算法有{%label 一个或多个输出 green%},这些输出是与输入有着某种特定关系的量.

**"好"算法特质**

- 正确性:正确地解决问题
- 可读性:算法应该具有良好的可读性,以帮助人们理解.
- 健壮性:输入非法数据时,算法能够适当地做出反映或进行处理,而不会产生莫名奇妙的输出结果
- 高效率和低存储量需求:时间复杂度和空间复杂度低

## 算法的时间复杂度

>**同阶无穷大**
>
>$O(1)<O(log n)<O(n)<O(nlog n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$

>**小结论**
>
>1. 顺序执行的代码只会影响常数项,可以忽略.
>2. 只需挑循环中的**一个基本操作**分析它的执行次数与n的关系即可
>3. 如果有多层嵌套循环,只需关注最深层循环循环了几次

**最好/最坏/平均时间复杂度**

## 算法的空间复杂度

**算法原地工作**:无论问题规模怎么变,算法所需的内存空间都是固定的常量,算法的空间复杂度为$O(1)$

**递归算法**:通常为递归调用的深度

# 线性表

## 线性表的定义和基本操作

**线性表**:具有{%label 相同数据类型 green%}的n(n>=0)个{%label 数据元素 green%}的{%label 有限序列 green%},其中n为{%label 表长 green%},当n=0时线性表是一个{%label 空表 green%}.若用L命名线性表,则其一般表示为

$$L = (a_1,a_2,a_i,a_{i+1},...a_n)$$

>$a_i$是线性表中的"第i个"元素,线性表中的位序
>
>$a_1$是表头元素,$a_n$是表尾元素
>
>除第一个元素外,每个元素有且仅有一个直接前驱,除最后一个元素外,每个元素有且仅有一个直接后继.

**基本操作**

- InitList(&L):初始化表.构造一个空的线性表L,分配内存空间
- DestroyList(%L):销毁操作.销毁线性表,并释放线性表L所占用的内存空间
- ListInsert(&L,i,e):插入操作.在线性表的第i个位置插入指定元素e
- ListDelete(&L,i,&e):删除操作.删除表L中第i个位置的元素,并用e返回删除元素的值.
- LocateElement(L,e):按值查找操作.在表L中查找具有给定关键字值的元素.
- GetElem(L,i):按位查找操作,获取表L中第i个位置的元素的值.
- Lengeh(L):求表长.返回线性表L的长度,即L中数据元素的个数.
- PrintList(L):输出操作.按前后顺序输出线性表L的所有元素值.
- Empty(L):判空操作.若L为空表,则返回true,否则返回false

## 顺序表的定义

**顺序表**:用{%label 顺序存储 green%}的方式实现线性表.

**实现方式**

- 静态分配

```cpp
    #include <stdio.h>
    #define MaxSize 10 // 定义最大长度
    typedef struct
    {
      int data[MaxSize];
      int length;
    } SqList;
    
    // 基本操作：初始化一个顺序表
    void InitList(SqList &L)
    {
      for (int i = 0; i < MaxSize; i++)
      {
        L.data[i] = 0; // 将所有数据元素设置为默认初始值
      }
      L.length = 0; // 顺序表的初始长度为0
    }
    
    int main()
    {
      SqList L;    // 声明一个顺序表
      InitList(L); // 初始化
      // TODO
      return 0;
    }									//顺序表的类型定义(静态分配方式)
```

- 动态分配

```cpp
#include <stdio.h>
#include <stdlib.h>

#define InitSize 10           // 默认的最大长度
typedef struct SeqList
{
  int *data;                  // 指示动态分配数组的指针
  int MaxSize;                // 顺序表的最大容量
  int length;                 // 顺序表的当前长度
};

void InitList(SeqList &L)
{
  L.data = (int *)malloc(InitSize * sizeof(int));     // 分配内存
  L.MaxSize = InitSize;                               // 初始化最大容量
  L.length = 0;                                       // 初始化当前长度
}

// 增加动态数组的长度
void IncreaseSize(SeqList &L, int len)
{
  int *p = L.data;                                    // 保存原数组指针
  L.data = (int *)malloc((L.MaxSize + len) * sizeof(int)); // 分配新的内存
  for (int i = 0; i < L.length; i++)
    L.data[i] = p[i];                                 // 将原数组元素拷贝到新数组
  L.MaxSize = L.MaxSize + len;
  free(p);                                            // 释放原数组的内存
}
```

**顺序表的特点**

- 随机访问:即可以在O(1)时间内找到第i个元素
- 存储密度高,每个节点只存储数据元素
- 拓展容量不方便(即便采用动态分配的方式实现,拓展长度的时间复杂度也比较高)
- 插入,删除操作不方便,需要移动大量元素.

## 顺序表的插入删除

**插入**

```cpp
// 基本操作：在L的位序i处插入元素e
void ListInsert(SqList &L, int i, int e)
{
  for(int j = L.length; j >= i; j--){   // 将第i个元素及之后的元素后移
    L.data[j] = L.data[j - 1];
  }
  L.data[i - 1] = e;                    // 在位序i处放入e
  L.length++;                           // 顺序表长度加1
}

// 增加健壮性后
bool ListInsert(SqList &L, int i, int e)
{
  if (i < 1 || i > L.length + 1)
    return false;
  if (L.length >= MaxSize)
    return false;
  for (int j = L.length; j >= i; j--)
  {
    L.data[j] = L.data[j - 1];
  }
  L.data[i - 1] = e;
  L.length++;
}
```

>时间复杂度分析:
>
>- 最好情况:新元素插入到表尾,不需要移动元素.i=n+1,循环0次,时间复杂度为O(1)
>- 最坏情况:新元素插入到表头,所有元素都需要移动,i=1,循环n次,时间复杂度为O(n);
>- 平均情况:假设新元素插入到任何一个位置的概率相同,即i=1,2,3,length+1的概率都是$p=\frac{1}{n+1}$,时间复杂度为O(n)

**删除**

```cpp
bool ListDelete(SqList &L,int i,int &e){
    if(i<1||i>L.length)			// 判断i的范围是否有效
        return false;
    e=L.data[i-1]				// 将被删除的元素赋值给e
    for(int j=i;j<L.length;j++){
        L.data[j-1]=L.data[j];
    }
    L.length--;
    return true;
}
int main(){
    SqList L;		//声明一个顺序表
    InitList(L);    // 初始化顺序表
    // 此处省略一些代码,插入几个元素
    int e = -1;		// 用变量e把删除的元素带回来
    if(ListDelete(L,3,e))
        printf("已删除第3个元素,删除元素值为=%d\n",e);
    else
        printf("位序i不合法,删除失败\n");
    return 0;
}
```

>时间复杂度分析:
>
>- 最好情况:删除表尾的元素,不需要移动元素.i=n+1,循环0次,时间复杂度为O(1)
>- 最坏情况:删除表头的元素,所有元素都需要移动,i=1,循环n次,时间复杂度为O(n);
>- 平均情况:删除任何一个位置的概率相同,即i=1,2,3,length+1的概率都是$p=\frac{1}{n+1}$,时间复杂度为O(n)

## 顺序表的查找

**按位查找**

`GetElem(L,i)`:按位查找操作.获取表L中第i个位置的元素的值.

```cpp
// 静态方式
#define MaxSize 10  // 定义最大长度
typedef struct SqList{
    ElemType data[MaxSize];
        int length;
};
ElemType GetElem(SqList L, int i){
    return L.data[i-1]
}
// 动态方式
#define InitSize 10
typedef struct SeqList{
    ElemType *data;
    int MaxSize;
    int length;
};
ElemType GetElem(SeqList L, int i){
    return L.data[i-1]			// 和访问普通数组的方法一样
}
```

>**时间复杂度**:O(1)

**按值查找**

`LocateElem(L,e)`:按值查找操作.在表L中查找具有给定关键字值的元素.

```cpp
#define InitSize 10   // 顺序表的初始长度
typedef struct{
    ElemType *data;	  // 指示动态分配数组的指针
    int MaxSize;	  // 顺序表的最大容量
    int length;		  // 顺序表的当前长度
}SeqList;

// 在顺序表L中查找第一个元素值等于e的元素,并返回其位序
int LocateElem(SeqList L, ElemType e){
    for(int i=0;i<L.length;i++){
        if(L.data[i]==e)
            return i+1;
    }
    return 0;
}
// 注意:结构类型的比较不能用==比较
// 需要依次对比各个分量来判断两个结构体是否相等
```

>时间复杂度分析:
>
>最好情况:O(1)
>
>最坏情况:O(n)
>
>平均情况:O(n)



## 单链表的定义

**单链表**:每个结点除了存放数据元素外,还要存储指向下一个节点的指针.

- 优点：不要求大片连续空间，改容量方便。
- 缺点：不可随机存储，要耗费一定空间存放指针。

```cpp
#include <stdio.h>
#include <stdlib.h>
struct LNode
{                     // 定义单链表结点类型
  ElemType data;      // 每个结点存放一个数据元素
  struct LNode *next; // 指针指向下一个结点
};
// 增加一个新结点
struct LNode *p = (struct LNode *)malloc(sizeof(struct LNode));
```

---

**使用typedef关键字来简化代码**

```cpp
#include <stdio.h>
#include <stdlib.h>

struct LNode{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;
```

要表示一个单链表时,只需声明一个{%label 头指针 green%}L,指向单链表的第一个结点

```cpp
LNode *L;			//声明一个指向单链表第一个结点的指针
// 或者也可以使用如下方式
LinkList L;			//声明一个指向单链表第一个结点的指针
```

LNode *L和LinkList L本质是一样的,不过前者更强调单独的一个结点,而后者更强调这是一个单链表整体.

**不带头结点的单链表**

```cpp
typedef struct LNode{			//定义单链表结点类型
    ElemType data;				//每个结点存放一个数据元素
    struct LNode *next;			//指针指向下一个结点
}LNode, *LinkList;				//将struct LNode 取别名为LNode,将struct LNode *取别名为LinkList
// 初始化一个空的单链表
bool InitList(LinkList &L){
    L = NULL;			//空表,暂时还没有任何结点
    return true;
}
// 判断单链表是否为空
bool Empty(LinkList L){
    return (L==NULL);
}

// 测试一下
void test {
    LinkList L;			//声明一个指向单链表的指针
    // 初始化一个空表
    InitList(L);
    // ... 后续代码
}
```

**带头结点的单链表**:推荐!!!

```cpp
typedef struct LNode{				//定义单链表结点类型
    ElemType data;					//每个结点存放一个数据元素
    struct LNode *next;				//指针指向下一个结点
}LNode, *LinkList;
// 初始化一个单链表(带头结点)
bool InitList(LinkList &L){
    L = (LNode *)malloc(sizeof(LNode));		//分配一个头结点
    if(L == NULL)						// 内存不足,分配失败
        return false;
    L->next = NULL;						//头结点之后暂时还没有结点
    return true;
}
void test(){
    LinkList L;							//声明一个指向单链表的指针
    // 初始化一个空表
    InitList(L);
    //... 后续代码
}
```


---
title: 数据结构与算法
date: 2024-05-20 19:45:25
tags: 数据结构与算法
categories: 笔记
---
# 绪论

## 数据结构的基本概念

**数据**:{% label 信息的载体 red%},是描述客观事物属性的数,字符及所有能输入到计算机中并被{% label 计算机程序识别和处理 red%}的符号的集合.

**数据元素**:数据的基本单位,通常作为一个整体进行考虑和处理

**数据项**:构成数据元素的不可分割的最小单位

**数据对象**:具有{% label 相同性质 red%}的数据元素的集合,是数据的一个子集

**数据结构**:相互之间存在一种或多种{% label 特定关系 red%}的数据元素的集合

## 数据结构的三要素

**逻辑结构**

- 集合结构
- 线性结构:一对一
- 树形结构:一对多
- 图状结构:多对多

**数据的运算**

- 创
- 销
- 增
- 删
- 改
- 查

**物理结构(存储结构)**

- 顺序存储
- 链式存储
- 索引存储
- 散列存储(哈希存储)

**数据类型**

数据类型是一个值的集合和定义在此集合上的一组操作的总称

- 原子类型:其值不可再分
- 结构类型: 其值可以再分解为若干分量

## 算法的基本概念

**算法**:{% label 对特定问题求解步骤的一种描述 red%},它是指令的有限序列,其中的每条指令表示一个或多个操作

**算法的特性**

- 有穷性:一个算法必须在执行有穷步之后结束,且每一步都可在又穷时间内完成
- 确定性: 算法中每条指令必须有确切的含义,对于{% label 相同的输入 blue %}只能得到{% label 相同的输出 blue %}
- 可行性: 算法中描述的操作都可以通过已经实现的{% label 基本运算执行有限次 red%}来实现
- 输入: 一个算法可以没有输入
- 输出:一个算法{% label 必须有输出 red%}

**好算法的特质**

- 正确性
- 可读性
- 健壮性
- 高效率和低存储需求

## 算法的复杂度

**时间复杂度**

- 加法规则:{% label 多项相加,只保留最高阶的项,且系数变为1 green%}
- 乘法规则: {% label 多项相乘,都保留 purple%}

>大小顺序
>
>$O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$

**结论**:

- 顺序执行的代码只会影响常数项,可以忽略
- 只需挑选循环中的{% label 一个基本操作分析 orange%}它的执行次数与n的关系即可
- 多层嵌套循环,只需要关注{% label 最深层 purple%}的循环

**三种复杂度**:

- 最坏时间复杂度
- 平均时间复杂度
- 最好时间复杂度

**空间复杂度**


# 线性表

## 定义

**线性表**是具有{% label 相同 blue%}数据类型的n(n >= 0) 个{% label 数据元素 purple%} 的{% label 有限序列 blue%},其中n为{% label 表长 red %},当n=0时,线性表是一个{% label 空表 red %}.若用L命名线性表,则一般表示为

$$L = (a_1,a_2,...,a_i,a_{i+1},...,a_n)$$

## 基本操作

- 创销增删改查
- 求表长
- 判空

## 顺序表

**顺序表**是用{% label 顺序存储 orange%}的方式实现的线性表

**顺序存储**: 把{% label 逻辑上相邻 green%}的元素存储在{% label 物理位置上也相邻 pink %}的存储单元中,元素之间的关系由存储单元的邻接关系来体现

**实现方式**

- 静态分配

```cpp
#include <stdio.h>
#define MaxSize 10  // 定义最大长度
typeof struct{
    int data[MaxSize]; //用静态的"数组"存放数据元素
    int length; 	   // 顺序表的当前长度
}SqList;			   // 顺序表的类型定义

//基本操作--初始化一个顺序表
void InitList(SqList &L){
    for(int i = 0; i<Maxsize;i++)
        L.data[i] = 0;   // 将所有数据元素设置为默认初始值
    L.length = 0;
}

int main(){
    SqList L;   //声明一个顺序表
    InitList(L);  //初始化顺序表
    return 0;
}
```

- 动态分配

```cpp
#include <stdlib.h>
#define InitSize 10		//顺序表的初始长度
typedef struct{
    int *data		//指示动态分配数组的指针
    int MaxSize;		//顺序表的最大长度
    int length;			//顺序表的当前长度
}SqList;				//顺序表的类型定义

void InitList(SqList &L){
    //用malloc函数申请一片连续的存储空间
    L.data = (int *)malloc(InitSize*sizeof(int));
    L.length = 0;
    L.MaxSize = InitSize;
}

//增加动态数组的长度
void IncreaseSize(SqList &L, int len){
    int *p = L.data;
    L.data = (int *)malloc((L.MaxSize+len)*sizeof(int));
    for(int i = 0;i<L.length;i++){
        L.data[i] = p[i];     //将数据复制到新区域
    }
    L.MaxSize = L.MaxSize + len;//顺序表的最大长度增加len
    free(p);                 //释放原来的内存空间
}
```

>**特点**
>
>- 随机访问,即可以在O(1)的时间内找到第i个元素
>- 存储密度较高,每个节点只存储数据元素
>- 拓展容量不方便(即便采用动态分配的方式实现,拓展长度的时间复杂度也比较高).


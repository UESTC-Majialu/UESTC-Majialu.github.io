---
title: 数据结构与算法
date: 2024-07-29 09:12:46
tags: 数据结构 算法
categories: 听课笔记
---

# 绪论

## **数据结构在学什么？**      

如何使用数据来表示生活中的问题.

## 数据结构的基本概念

![](数据元素和数据项.png)

**数据**：数据是{%label 信息的载体 green%}，是描述客观事物属性的数，字符及所有能输入到计算机中{%label 并被计算机程序识别和处理 green%}的符号的集合。数据是计算机程序加工的原料。

**数据元素**：是数据的{%label 基本单位 green%}，通常作为一个整体进行考虑和处理。一个数据元素可由若干{%label 数据项 green%}组成，数据项是构成数据元素的不可分割的最小单位。

![](数据对象.png)

**数据对象**:具有{%label 相同性质 green%}的数据元素的集合，是数据的一个子集。

**数据结构**:相互之间存在一种或多种{%label 特定关系 green%}的数据元素的集合。

**数据类型**：一个值的集合和定义在此集合上的一组操作的总称。

- 原子类型：其值不可再分的数据类型，如bool类型，int类型
- 结构类型：其值可以再分解为若干成分(分量)的数据类型

```cpp
struct Coordinate {
    int x;
    int y;
}
```

**抽象数据类型**(Abstract Data Type,ADT): 是抽象数据组织及与之相关的操作.

## 数据结构的三要素

### 逻辑结构

**集合**：各个元素同属于一个集合，并无其他关系

**线性结构**：数据元素之间是{%label 一对一的关系 green%}的关系。除了第一个元素，都有一个唯一的前驱。除了最后一个元素，所有的元素都有唯一后继。

**树形结构**：数据元素之间的{%label 一对多 green%}的关系。

**图结构**:数据元素之间是{%label 多对多的关系 green%}

### 数据的运算

结合逻辑结构，实际需求来定义基本运算。

### 物理结构(存储结构)

如何用计算机实现这种数据结构

- 顺序存储：把{%label 逻辑上相邻的元素存储在物理位置上也相邻的存储单元中 green%}，元素之间的关系由存储单元的邻接关系来体现。
- 链式存储：{%label 逻辑上相邻的元素在物理位置上可以不相邻 green%}，借助指数元素存储地址的指针来表示元素之间的逻辑关系。
- 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为{%label 索引项 green%}，索引项的一般形式是{%label (关键字，地址) green%}
- 散列存储(Hash存储): 根据元素的关键字直接计算出该元素的存储地址。

>运算的定义是针对逻辑结构的，指出运算的功能。
>
>运算的实现是针对存储结构的，指出运算的具体操作步骤。



## 算法的基本概念

**算法**(Algorithm):对{%label 特定问题求解步骤的一种描述 green%},它是指令的有限序列,其中每条指令表示一个或多个操作.

**算法的特性**:

- 有穷性:一个算法必须总在执行有穷步之后结束,且每一步都可在又穷时间内完成.
- 确定性:算法中每条指令必须有确切的含义,对于{%label 相同的输入 green%}只能得到{%label 相同的输出 green%}.
- 可行性:算法中描述的操作都可以通过已经实现的{%label 基本运算执行有限次 green%}来实现.
- 输入:一个算法有{%label 零个或多个输入 green%},这些输入取自于某个特定的对象的集合.
- 输出:一个算法有{%label 一个或多个输出 green%},这些输出是与输入有着某种特定关系的量.

**"好"算法特质**

- 正确性:正确地解决问题
- 可读性:算法应该具有良好的可读性,以帮助人们理解.
- 健壮性:输入非法数据时,算法能够适当地做出反映或进行处理,而不会产生莫名奇妙的输出结果
- 高效率和低存储量需求:时间复杂度和空间复杂度低

## 算法的时间复杂度

>**同阶无穷大**
>
>$O(1)<O(log n)<O(n)<O(nlog n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$

>**小结论**
>
>1. 顺序执行的代码只会影响常数项,可以忽略.
>2. 只需挑循环中的**一个基本操作**分析它的执行次数与n的关系即可
>3. 如果有多层嵌套循环,只需关注最深层循环循环了几次

**最好/最坏/平均时间复杂度**

## 算法的空间复杂度

**算法原地工作**:无论问题规模怎么变,算法所需的内存空间都是固定的常量,算法的空间复杂度为$O(1)$

**递归算法**:通常为递归调用的深度

# 线性表

## 线性表的定义和基本操作

**线性表**:具有{%label 相同数据类型 green%}的n(n>=0)个{%label 数据元素 green%}的{%label 有限序列 green%},其中n为{%label 表长 green%},当n=0时线性表是一个{%label 空表 green%}.若用L命名线性表,则其一般表示为

$$L = (a_1,a_2,a_i,a_{i+1},...a_n)$$

>$a_i$是线性表中的"第i个"元素,线性表中的位序
>
>$a_1$是表头元素,$a_n$是表尾元素
>
>除第一个元素外,每个元素有且仅有一个直接前驱,除最后一个元素外,每个元素有且仅有一个直接后继.

**基本操作**

- InitList(&L):初始化表.构造一个空的线性表L,分配内存空间
- DestroyList(%L):销毁操作.销毁线性表,并释放线性表L所占用的内存空间
- ListInsert(&L,i,e):插入操作.在线性表的第i个位置插入指定元素e
- ListDelete(&L,i,&e):删除操作.删除表L中第i个位置的元素,并用e返回删除元素的值.
- LocateElement(L,e):按值查找操作.在表L中查找具有给定关键字值的元素.
- GetElem(L,i):按位查找操作,获取表L中第i个位置的元素的值.
- Lengeh(L):求表长.返回线性表L的长度,即L中数据元素的个数.
- PrintList(L):输出操作.按前后顺序输出线性表L的所有元素值.
- Empty(L):判空操作.若L为空表,则返回true,否则返回false

## 顺序表的定义

**顺序表**:用{%label 顺序存储 green%}的方式实现线性表.

**实现方式**

- 静态分配

```cpp
    #include <stdio.h>
    #define MaxSize 10 // 定义最大长度
    typedef struct
    {
      int data[MaxSize];
      int length;
    } SqList;
    
    // 基本操作：初始化一个顺序表
    void InitList(SqList &L)
    {
      for (int i = 0; i < MaxSize; i++)
      {
        L.data[i] = 0; // 将所有数据元素设置为默认初始值
      }
      L.length = 0; // 顺序表的初始长度为0
    }
    
    int main()
    {
      SqList L;    // 声明一个顺序表
      InitList(L); // 初始化
      // TODO
      return 0;
    }									//顺序表的类型定义(静态分配方式)
```

- 动态分配

```cpp
#include <stdio.h>
#include <stdlib.h>

#define InitSize 10           // 默认的最大长度
typedef struct SeqList
{
  int *data;                  // 指示动态分配数组的指针
  int MaxSize;                // 顺序表的最大容量
  int length;                 // 顺序表的当前长度
};

void InitList(SeqList &L)
{
  L.data = (int *)malloc(InitSize * sizeof(int));     // 分配内存
  L.MaxSize = InitSize;                               // 初始化最大容量
  L.length = 0;                                       // 初始化当前长度
}

// 增加动态数组的长度
void IncreaseSize(SeqList &L, int len)
{
  int *p = L.data;                                    // 保存原数组指针
  L.data = (int *)malloc((L.MaxSize + len) * sizeof(int)); // 分配新的内存
  for (int i = 0; i < L.length; i++)
    L.data[i] = p[i];                                 // 将原数组元素拷贝到新数组
  L.MaxSize = L.MaxSize + len;
  free(p);                                            // 释放原数组的内存
}
```

**顺序表的特点**

- 随机访问:即可以在O(1)时间内找到第i个元素
- 存储密度高,每个节点只存储数据元素
- 拓展容量不方便(即便采用动态分配的方式实现,拓展长度的时间复杂度也比较高)
- 插入,删除操作不方便,需要移动大量元素.

## 顺序表的插入删除

**插入**

```cpp
// 基本操作：在L的位序i处插入元素e
void ListInsert(SqList &L, int i, int e)
{
  for(int j = L.length; j >= i; j--){   // 将第i个元素及之后的元素后移
    L.data[j] = L.data[j - 1];
  }
  L.data[i - 1] = e;                    // 在位序i处放入e
  L.length++;                           // 顺序表长度加1
}

// 增加健壮性后
bool ListInsert(SqList &L, int i, int e)
{
  if (i < 1 || i > L.length + 1)
    return false;
  if (L.length >= MaxSize)
    return false;
  for (int j = L.length; j >= i; j--)
  {
    L.data[j] = L.data[j - 1];
  }
  L.data[i - 1] = e;
  L.length++;
}
```

>时间复杂度分析:
>
>- 最好情况:新元素插入到表尾,不需要移动元素.i=n+1,循环0次,时间复杂度为O(1)
>- 最坏情况:新元素插入到表头,所有元素都需要移动,i=1,循环n次,时间复杂度为O(n);
>- 平均情况:假设新元素插入到任何一个位置的概率相同,即i=1,2,3,length+1的概率都是$p=\frac{1}{n+1}$,时间复杂度为O(n)

**删除**

```cpp
bool ListDelete(SqList &L,int i,int &e){
    if(i<1||i>L.length)			// 判断i的范围是否有效
        return false;
    e=L.data[i-1]				// 将被删除的元素赋值给e
    for(int j=i;j<L.length;j++){
        L.data[j-1]=L.data[j];
    }
    L.length--;
    return true;
}
int main(){
    SqList L;		//声明一个顺序表
    InitList(L);    // 初始化顺序表
    // 此处省略一些代码,插入几个元素
    int e = -1;		// 用变量e把删除的元素带回来
    if(ListDelete(L,3,e))
        printf("已删除第3个元素,删除元素值为=%d\n",e);
    else
        printf("位序i不合法,删除失败\n");
    return 0;
}
```

>时间复杂度分析:
>
>- 最好情况:删除表尾的元素,不需要移动元素.i=n+1,循环0次,时间复杂度为O(1)
>- 最坏情况:删除表头的元素,所有元素都需要移动,i=1,循环n次,时间复杂度为O(n);
>- 平均情况:删除任何一个位置的概率相同,即i=1,2,3,length+1的概率都是$p=\frac{1}{n+1}$,时间复杂度为O(n)

## 顺序表的查找

**按位查找**

`GetElem(L,i)`:按位查找操作.获取表L中第i个位置的元素的值.

```cpp
// 静态方式
#define MaxSize 10  // 定义最大长度
typedef struct SqList{
    ElemType data[MaxSize];
        int length;
};
ElemType GetElem(SqList L, int i){
    return L.data[i-1]
}
// 动态方式
#define InitSize 10
typedef struct SeqList{
    ElemType *data;
    int MaxSize;
    int length;
};
ElemType GetElem(SeqList L, int i){
    return L.data[i-1]			// 和访问普通数组的方法一样
}
```

>**时间复杂度**:O(1)

**按值查找**

`LocateElem(L,e)`:按值查找操作.在表L中查找具有给定关键字值的元素.

```cpp
#define InitSize 10   // 顺序表的初始长度
typedef struct{
    ElemType *data;	  // 指示动态分配数组的指针
    int MaxSize;	  // 顺序表的最大容量
    int length;		  // 顺序表的当前长度
}SeqList;

// 在顺序表L中查找第一个元素值等于e的元素,并返回其位序
int LocateElem(SeqList L, ElemType e){
    for(int i=0;i<L.length;i++){
        if(L.data[i]==e)
            return i+1;
    }
    return 0;
}
// 注意:结构类型的比较不能用==比较
// 需要依次对比各个分量来判断两个结构体是否相等
```

>时间复杂度分析:
>
>最好情况:O(1)
>
>最坏情况:O(n)
>
>平均情况:O(n)



## 单链表的定义

**单链表**:每个结点除了存放数据元素外,还要存储指向下一个节点的指针.

- 优点：不要求大片连续空间，改容量方便。
- 缺点：不可随机存储，要耗费一定空间存放指针。

```cpp
#include <stdio.h>
#include <stdlib.h>
struct LNode
{                     // 定义单链表结点类型
  ElemType data;      // 每个结点存放一个数据元素
  struct LNode *next; // 指针指向下一个结点
};
// 增加一个新结点
struct LNode *p = (struct LNode *)malloc(sizeof(struct LNode));
```

---

**使用typedef关键字来简化代码**

```cpp
#include <stdio.h>
#include <stdlib.h>

struct LNode{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;
```

要表示一个单链表时,只需声明一个{%label 头指针 green%}L,指向单链表的第一个结点

```cpp
LNode *L;			//声明一个指向单链表第一个结点的指针
// 或者也可以使用如下方式
LinkList L;			//声明一个指向单链表第一个结点的指针
```

LNode *L和LinkList L本质是一样的,不过前者更强调单独的一个结点,而后者更强调这是一个单链表整体.

**不带头结点的单链表**

```cpp
typedef struct LNode{			//定义单链表结点类型
    ElemType data;				//每个结点存放一个数据元素
    struct LNode *next;			//指针指向下一个结点
}LNode, *LinkList;				//将struct LNode 取别名为LNode,将struct LNode *取别名为LinkList
// 初始化一个空的单链表
bool InitList(LinkList &L){
    L = NULL;			//空表,暂时还没有任何结点
    return true;
}
// 判断单链表是否为空
bool Empty(LinkList L){
    return (L==NULL);
}

// 测试一下
void test {
    LinkList L;			//声明一个指向单链表的指针
    // 初始化一个空表
    InitList(L);
    // ... 后续代码
}
```

**带头结点的单链表**:推荐!!

```cpp
typedef struct LNode{				//定义单链表结点类型
    ElemType data;					//每个结点存放一个数据元素
    struct LNode *next;				//指针指向下一个结点
}LNode, *LinkList;
// 初始化一个单链表(带头结点)
bool InitList(LinkList &L){
    L = (LNode *)malloc(sizeof(LNode));		//分配一个头结点
    if(L == NULL)						// 内存不足,分配失败
        return false;
    L->next = NULL;						//头结点之后暂时还没有结点
    return true;
}
void test(){
    LinkList L;							//声明一个指向单链表的指针
    // 初始化一个空表
    InitList(L);
    //... 后续代码
}
```

## 单链表的插入删除

**带头结点**

ListInsert(&L,i,e):插入操作，在表L中第i个位置插入指定元素e

需要找到第i-1个结点，将新结点插入其中

```cpp
// 定义一个单链表
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;
// 在第i个位置插入元素e(带头结点)
bool ListInsert(LinkList &L, int i, ElemType e){
    if(i<1)
        return false;
    LNode *p;			//指针p指向当前扫描到的结点
    int j=0;			//当前p指向的是第几个结点
    p = L;				//L指向头结点，头结点是第0个结点(不存数据)
    while(p!=NULL && j<i-1){
        //循环找到第i-1个结点
        p=p->next;
        j++:
    }
    if(p==NULL)			//i值不合法
        return false;
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data=e;
    s->next=p->next;
    p->next=s;		//将结点s连到p之后
    return true;     //插入成功
}
```

>**时间复杂度分析**
>
>最好情况：在表头插入，O(1)
>
>最坏情况/平均情况: O(n)

**不带头结点**

```cpp
// 定义一个单链表
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

//按位序插入(不带头结点)
bool ListInsert(LinkList &L,int i, ElemType e){
    if(i<1)
        return false;
    if(i==1){
        // 插入第一个结点的操作与其他结点的不同
        LNode *s = (LNode *)malloc(sizeof(LNode));
        s->data = e;
        s->next = L;
        L = s;     // 头指针指向新结点
        return true;
    }
    LNode *p;		//指针p指向当前扫描到的结点
    int j=1;		//当前p指向的是第几个结点
    p = L;			//p指向第1个结点(注意：不是头结点)
    while(p!=NULL && j<i-1){
        //循环找到第i-1个结点
        p=p->next;
        j++;
    }
    if(p==NULL)			//i值不合法
        return false;
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;		//插入成功
}

```

**指定结点的后插操作**

```cpp
// 后插操作：在结点p之后出入元素e
// 时间复杂度,O(1)
bool InsertNextNode (LNode *p, ElemType e){
    if(p==NULL)
        return false;
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if(s==NULL)		//内存分配失败
        return false;
    s->data = e;		//用结点s存放数据元素e
    s->next = p->next;
    p->next = s;		//将结点s连到p之后
    return true;
}
```

**指定结点的前插操作**

```cpp
// 前插操作：在p结点之前插入元素e
// 传入头指针，遍历整个链表，找到p结点的前驱节点，在其之后插入e
// 时间复杂度O(n)
//bool InsertPriorNode(LinkList L, LNode *p, ElemType e)
    
// 第二种方式，先在p结点之后插入新结点，再将p的元素赋值给新结点，将e赋值给p结点
bool InsertPriorNode(LNode *p,ElemType e){
    if(p==NULL)
        return false;
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if(s==NULL)			//内存分配失败
        return false;
    s->next = p->next;
    p->next = s;		//新结点s连到p之后
    s->data=p->data;	//将p中元素复制到s中
    p->data=e;			//将p中元素覆盖为e
    return true;		//前插成功
}
```

**按位序删除**(带头结点)

```cpp
bool ListDelete(LinkList &L,int i,ElemType &e){
    if(i<1)
        return false;
    LNode *p;		//指针p指向当前扫描到的结点
    int j=0;		//当前p指向的是第几个结点
    p = L;			//L指向头结点,头结点是第0个结点(不存数据)
    while(p!=NULL & j<i-1){
        p=p->next;
        j++;
    }
    if(p==NULL)		//i值不合法
        return false;
    if(p->next==NULL)	//第i-1结点之后已无其他结点
        return false;
    LNode *q = p->next;	//令q指向被删除的结点
    e = q->data;		//用e返回元素的值
    p->next=q->next;	//将*q结点从链中断开
    free(q);			//释放结点的存储空间
    return true;		//删除成功
}
```

>最好情况:O(1)
>
>最坏情况/平均情况:O(n)

**指定结点的删除**

```cpp
// 删除指定的结点p
bool DeleteNode(LNode *p){
    if(p==NULL)
        return false;
    LNode *q = p->next;		//令q指向*p的后继节点
    p->data=p->next->data;	//和后继节点交换数据域
    p->next=q->next;		//将*q结点从链中断开
    free(q);				//释放后继结点的存储空间
    return true;
}
// 如果*p是最后一个节点的话,不能ci'a'y
```

## 单链表的查找

**按位查找**

GetElem(L,i):按位查找，获取表L中第i个位置的元素.

```cpp
//按位查找，返回第i个元素(带头结点)
LNode *GetElem(LinkList L,int i){
    if(i<0)
        return NULL;
    LNode *p;		//指针p指向当前扫描到的结点
    int j=0;		//当前p指向的是第几个结点
    p = L;			//L指向头结点，头结点是第0个结点，不存数据
    while(p!==NULL && j<i){
        p=p->next;
        j++;
    }
    return p;
}
```

>最好情况:O(1)
>
>最差情况/平均情况:O(n)

**按值查找**

LocateElem(L,e):按值查找，再表L中查找具有给定关键字值的元素

```cpp
//按值查找，找到数据域==e的结点
LNode *LocateElem(LinkList L,ElemType e){
    LNode *p = L->next;
    //从第1个结点开始查找数据域为e的结点
    while(p!==NULL && p->data != e)
        p = p->next;
    return p;		//找到后返回该结点指针，否则返回NULL
}
```

>最好情况:O(1)
>
>最差情况/平均情况:O(n)

**求表的长度**

```cpp
//求表的长度
int Length(LinkList L){
    int len = 0;		//统计表长
    LNode *p = L;
    while(p->next != NULL){
        p = p->next;
        len++;
    }
    return len;
}
```

>时间复杂度:O(n)

## 单链表的建立

**尾插法**

```cpp
#include <stdio.h>
#include <stdlib.h>
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;
LinkList LinkList_TailInsert(LinkList &L){
    int x;					//设置ElemType为整形
    L = (LinkList)malloc(sizeof(LNode)); //建立头结点
    LNode *s,*r = L;		//r为表尾指针
    scanf("%d",&x);			//输入结点的值
    while(x!=9999){
        //输入9999表示结束
        s = (LNode *)malloc(sizeof(LNode));
        s->data=x;
        r->next=s;
        r=s;			//r指向新的表尾结点
        scanf("%d",&x);
    }
    r->next=NULL;
    return L;
}
```

**头插法**

```cpp
LinkList_HeadInsert(LinkList &L){
    LNode *s;
    int x;
    L=(LinkList)malloc(sizeof(LNode));		//创建头结点
    L->next = NULL;						//初始为空链表
    scanf("%d",&x);						//输入结点的值
    while(x!=9999){
        //输入9999表示结束
        s = (LNode *)malloc(sizeof(LNode));	//创建新结点
        s->data=x;
        s->next=L->next;
        L-next=s;	//将新结点插入表中，L为头指针
        scanf("%d",&x);
    }
    return L;
}
```

## 双链表

```cpp
typedef struct DNode{
    ElemType data;
    struct DNode *prior,*next;	//前驱和后继指针
}DNode, *DLinkList;

```

```cpp
//初始化双链表(带头结点)
bool InitDLinkList(DLinkList &L){
    L = (DNode *)malloc(sizeof(DNode));	//分配一个头结点
    if(L==NULL)		//内存不足,分配失败
        return false;
    L->prior = NULL;		//头结点的prior永远指向NULL
    L->next = NULL;			//头结点之后暂时还没有结点
    return true;
}
```

```cpp
//在p结点之后插入s结点
bool InsertNextDNode(DNeode *p, DNode *s){
    if(p==NULL||s==NULL)		//非法参数
        return false;
    s->next=p->next;
    if(p->next!=NULL)		//如果p结点还有后继节点
        p->next-prior=s;
    s->prior=p;
    p->next=s;
    return true;
}
```

```cpp
//删除p的后继节点q
bool DeleteNextDNode(DNode *p){
    if(p==NULL) return false;
    DNode *q = p->next;	//找到p的后继结点q
    if(q==NULL) return false;	//p没有后继
    p->next=q->next;
    if(p->next!=NULL)`		//q有后继结点
        q->next->prior=p;
    free(q);		//释放结点空间
    return true;
}
```

```cpp
//双链表的遍历
//后向遍历
while(p!=NULL){
    p=p->next;
}
//前向遍历
while(p!=NULL){
    p=p->prior;
}
//前向遍历(跳过头结点)
while(p->prior!=NULL){
    p=p->prior;
}
// 时间复杂度:O(n)
```

## 循环链表

**循环单链表**

```cpp
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;
//初始化一个循环单链表
bool InitList(LinkList &L){
    L = (LNode *)malloc(sizeof(LNode));//分配一个头结点
    if(L==NULL)
        return false;
    L->next=L;		//头结点的next指向头结点
    return true;
}
//判断循环单链表是否为空
bool Empty(LinkList L){
    if(L->next=L)
        return true;
    else
        return false;
}
//判断p结点是否为循环单链表的表尾结点
bool isTail(LinkList L,LNode *p){
    if(p->next==L)
        return true;
    else
        return false;
}
```

**循环双链表**

```cpp
//初始化空的循环双链表
bool InitDLinkList(DLinkList &L){
    L = (DNode *)malloc(siezeof(DNode));//分配一个头结点
    if(L==NULL)
        return false;
    L->prior=L;
    L->next=L;
    return true;
}
//判断循环双链表是否为空
bool Empty(DLinkList L){
    if(L->next==L)
        return true;
    else
        return false;
}
// 判断p结点是否是循环双链表的表尾结点
bool isTail(DLinkList L,DNode *p){
    if(p->next=L)
        return true;
    else
        return false;
}
```

## 静态链表

**单链表**：各个节点在内存中星罗棋布，散落天涯

**静态链表**：分配一整片连续的内存空间，各个结点集中安置

```cpp
#define MaxSize 10  // 静态链表的最大长度
struct Node{
    ElemType data;
    int next;		//下一个元素的数组下标
};
typedef struct {
    int data;
    int next;
}SLinkList[MaxSize];

void testSLinkList(){
    struct Node x;
    printf("sizeX=%d\n",sizeof(x));
 	
    struct Node a[MaxiSize];
    printf("sizeA=%d\n",sizeof(a));
    
    SLinkList b;
    printf("sizeB=%d\n",sizeof(b));
}
//输出结果
// sizeX=8
// sizeA=80
// sizeB=80
```

>查找:O(n)

## 顺序表VS链表

|            | 顺序表                                                       | 链表                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 逻辑结构   | 线性结构                                                     | 线性结构                                                     |
| 物理结构   | 顺序存储,支持随机存取,存储密度高;大片连续空间分配不方便,改变容量不方便 | 链式存储,离散的空间分配方便,改变容量方便;不可随机存储,存储密度低 |
| 数据的运算 | 静态自动回收,动态手动free                                    | 遍历free                                                     |
| 适用情况   | 表长可以估计,经常进行查询                                    | 表长难以估计,需要经常增删改查                                |

# 栈和队列

## 栈的基本概念

**栈**(Stack)是只允许在一端进行插入或删除操作的线性表

**栈顶**:允许进行插入和删除的一端

**栈底**:不允许进行插入和删除的一端

**空栈**:没有元素的栈

特点:后进先出(Last in First Out,LIFO)

**常考题型**:n个不同元素进栈,出栈元素不同的排列的个数为$\frac{1}{n+1}C_{2n}^n$,上述公式称为卡特兰数,可采用数学归纳法证明.

## 栈的顺序存储实现

```cpp
#define MaxSize 10
typedef struct{
    ElemType data[MaxSize];
    int top;			//栈顶指针
}SqStack;

//初始化栈
void InitStack(SqStack &S){
    S.top=-1;			//初始化栈顶指针
}

//判断栈空
bool StackEmpty(SqStack S){
    return S.top==-1;		
}

//新元素入栈
bool Push(SqStack &S, ElemType x){
    if(S.top===MaxSize-1)
        //栈满,报错
        return false;
    //一下两行可以简写为
    //S.data[++S.top]=x;
    S.top++;
    S.data[S.top]=x;	//新元素入栈
    return true;
}
// 出栈操作
bool Pop(SqStack &S,ElemType &x){
    if(S.top==-1)
        return false;
    x=S.data[S.top--];	//栈顶元素先出栈,再将指针-1
    return true;
}
//读取栈顶元素
bool Pop(SqStack &S,ElemType &x){
    if(S.top==-1)
        return false;
    x=S.data[S.top];
    return true;
}

void testStack(){
    SqStack S;		//声明一个顺序栈(分配空间)
    // 后续操作
}
//栈满条件:S,top = MaxSize
```

**共享栈**:两个栈共享同一片空间

```cpp
#define MaxSize 10
typedef struct{
    ElemType data[MaxSize];
    int top0;
    int top1;
}ShStack;
//初始化栈
void InitStack(ShStack &S){
    S.top0=-1;
    S.top1=MaxSize;
}
//栈满的条件:top0+1=top1
```

## 栈的链式存储

**定义**

```cpp
//链栈的定义
typedef struct Linknode{
    ElemType data;
    struct Linknode *next;
}*LiStack;

```

## 队列的基本概念

**队列**(Queue):先进先出(First in first out,FIFO)

**重要术语**:队头,队尾,空队列

## 队列的顺序实现

```cpp
//循环队列
#define MaxSize 10
typedef struct{
    ElemType data[MaxSize];		//用静态数组存放队列元素
    int front,rear		//队头指针和队尾指针
}SqQueue;

//初始化队列
void InitQueue(SqQueue &Q){
    //初始时,队头,队尾指针指向0
    Q.rear=Q.front=0;
}
//判断队列是否为空
bool QueueEmpty(SqQueue Q){
    if(Q.rear==Q.front)
        return true;
    else
        return false;
}
//入队
bool EnQueue(SqQueue &Q,ElemType x){
    if((Q.rear+1)%MaxSize==Q.front)
        return false;
    Q.data[Q.rear]=x;
    Q.rear=(Q.rear+1)%MaxSize;  //队尾指针加1取模运算
    return true;
}
//出队(删除一个队头元素,并用x返回)
bool DeQueue(SqQueue, &Q,ElemType &x){
    if(Q.rear==Q.front)
        return false; //队空
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%MaxSize;	//指针后移
    retrun true;
}
//获取队头元素的值,用x返回
bool GetHead(SqQueue Q,ElemType &x){
    if(Q.rear==Q.front)
        return false;
    x=Q.data[Q.front];
    return true;
}

void testQueue(){
    SqQueue Q;
}

```

**判断队列已满/已空的方法**

- 方法1
  - 已满:rear+1==front
  - 已空:rear==front
- 方法2:设计size来表示当前队列的长度
  - 已满:size==MaxSize
  - 已空:size==0
- 方法3:用tag来表示队列的上一次操作,每次删除成功,令tag=0;插入成功令tag=1;
  - 已满:rear==front&&tag=1
  - 已空:rear==front&&tag=0

## 队列的链式实现


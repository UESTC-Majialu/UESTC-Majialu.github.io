---
title: 笔试真题
date: 2024-07-25 16:27:53
tags: 刷题
categories: 刷题笔记
top_img: 顶部图.jpg
cover: 缩略图.jpg
---
# OPPO 24届秋招正式批笔试

>**考点分析**

![](考点分析.png)

## CSS权重

>**题号**：0001
>
>**来源**：OPPO
>
>**知识点**：css权重分析
>
>**时间**: 2024-07-25

执行以下程序，对于①②式能否在a标签上实现效果，下列说法正确的是（）

```html
div {

        width:200px;

        height: 200px;

        text-decoration: none; ...①

        font-size:12px; ...②

}

<div class="father">

      <a href = "#">跳转</a>

</div>
```

![](0001.png)

>**正确答案**:D
>
>**官方题解**:
>
>text-decoration和font-size都是定义在a的父级元素上，通过让a元素继承这两个属性来实现效果。事实上，这两个属性都是可继承的，但不同的是，a标签自身还有默认属性text-decoration和color，该默认样式的权重比继承的高（继承的权重为0），因此①式并没有在a标签上起效果，而a标签的默认样式属性中没有font-size，因此②式可以起效果。



在CSS中，元素的样式可以被多个规则所影响。当这些规则发生冲突时，浏览器需要决定哪个规则应该优先应用。这就涉及到CSS中的“权重”（或称为“特异性”）概念。

**CSS权重的基本原则**

CSS权重是根据选择器的不同类型来计算的，权重值越高，则该选择器的优先级越高。权重由高到低分为四个等级：

1. **内联样式** (`style` 属性)：权重为 1000。

   - 例如：`<p style="color: red;">This text is red.</p>`

2. **标识符选择器** (`#id`)：每个标识符选择器权重为 100。

   - 例如：`#myID { color: blue; }`

3. **类选择器** (`.class`)、属性选择器 (`[attribute]`) 和伪类 (`:hover`, `:first-child` 等)：每个类选择器、属性选择器或伪类的权重为 10。

   - 例如：

     ```
     .myClass { color: green; }
     ```

     - 或者：`a:hover { color: yellow; }`

4. **类型选择器** (`element`) 和伪元素 (`::before`, `::after` 等)：每个类型选择器或伪元素的权重为 1。

   - 例如：

     ```
     p { color: orange; }
     ```

     - 或者：`p::first-letter { color: purple; }`

5. **通用选择器** (`*`, `div`, `p` 等)、子代选择器 (`>`), 相邻同胞选择器 (`+`), 一般同胞选择器 (`~`) 和伪关键字 `:not()` 的权重为 0。

   - 例如：

     ```
     * { color: black; }
     ```

     - 或者：`div > p { color: gray; }`

6. **继承** 和 **用户代理样式表** 的权重为 0，但它们具有默认优先级。

   - 浏览器默认的样式。

7. **`!important` 标志**：在样式声明后加上 `!important` 可以提高权重，其权重高于所有其他权重，但低于内联样式中的 `!important`。

   - 例如：`p { color: blue !important; }`

**计算权重的步骤**

- 对于一个给定的选择器，计算每个级别的权重总和。
- 如果两个选择器的权重相同，则离元素更近的选择器优先（更具体的上下文）。
- 如果权重仍然相同，最后声明的规则将优先（CSS的层叠规则）。

**示例**

假设我们有以下CSS规则：

1. `p { color: blue; }` （权重为 1）
2. `.redText { color: red; }` （权重为 10）
3. `#special { color: green; }` （权重为 100）

如果一个段落同时使用了类 `.redText` 和 ID `#special`，那么最终的颜色将是绿色，因为 ID 选择器的权重更高。

**复杂选择器**

当选择器包含多个部分时，将每个部分的权重相加。例如，`#myID .myClass` 的权重为 100 + 10 = 110。

**总结**

理解CSS权重可以帮助你更好地控制页面样式的优先级，避免不必要的覆盖和冲突。尽量避免过度使用高权重的选择器（如 `!important`），因为它可能会导致样式难以管理和维护。

---

## CSS属性


>**题号**：0002
>
>**来源**：OPPO
>
>**知识点**：行内元素和块级元素
>
>**时间**: 2024-07-25

![](0002.png)

>**正确答案**:B
>
>**官方解析**:vertical-align在行内元素中设置有效，在块级元素中设置无效，即使块级元素嵌套了行内元素，行内元素也不会继承块级元素的该属性，故B选项符合要求；ACD选项均在块级元素中设置有效，作用在块级元素内的文本等内容。

---

## BFC(Block Formatting Context)

>**题号**:0003
>
>**来源**:OPPO
>
>**知识点**:BFC
>
>**时间**：2024-07-28

执行一下程序，当给main盒子添加overflow:hidden；则变化情况为

```html
<style>
.box {
        width: 200px;
        height: 300px;
}
.sideBar {
        float: left;
        width: 50px;
        height: 100px;
}
.main {
        height: 200px;
}
</style>
<div class="box">
        <div class="sideBar"></div>
        <div class="main"></div>
</div>
```

![](0003.png)

>**正确答案**:B
>
>**官方解析**:
>
>添加前，由于sideBar盒子设置了浮动，因此main盒子会移动并占据sideBar盒子的位置，结果是main盒子紧贴在sideBar盒子的左边，添加后，overflow:hidden触发产生新的bfc。根据bfc的布局规则，bfc区域不会与浮动元素的区域发生重叠，因此，main盒子会紧贴在sideBar盒子的右边。

**常规流,块盒**

1. 水平方向上,撑满整个包含块宽度,垂直方向上,依次摆放
2. 垂直方向上相邻的元素,margin会合并(取两者中的最大值)
3. 父子关系的情况下,可能会产生margin塌陷
4. 父子关系的情况下,父元素无视浮动元素会产生高度坍塌
5. 兄弟关系的情况下,正常元素可能会被浮动元素覆盖(正常元素在浮动元素之后)

**BFC**(Block Formatting Context)区块格式化上下文

1. 开启BFC的区域,是一块{%label 独立的渲染区域 green%}
2. {%label 隔绝了内部与外部的联系 green%},内部渲染不会影响到外部
3. 不同的BFC区域,{%label 渲染时也互不干扰 green%}

**开启BFC能解决什么问题**

1. 开启BFC，其{%label 子元素 green%}不会再产生margin塌陷问题(不会和他的子元素产生margin合并)
2. 开启BFC，就算子元素浮动，{%label 自身高度也不会坍塌 green%}(计算高度时不再无视浮动元素)
3. 开启BFC，{%label 自己不会被其他浮动元素所覆盖 green%}(不会与浮动元素重叠，会避开浮动元素排布)

**如何开启BFC**

1. 根元素(HTML)自身是一个BFC
2. 设置{%label float green%}属性
3. 设置{%label position green%}属性为设置{%label absolute或fixed green%}
4. 设置{%label overflow green%}属性值{%label 不为visible green%}
5. 行内块盒({%label inline-block green%})
6. 设置{%label display green%}为{%label flow-root green%}的元素
7. 伸缩项目({%label flex盒子内的item green%})
8. 多列容器(设置{%label column-count green%})
9. 表格元素(table thead tbody tfoot tr th td caption)
10. column-span为all的元素(表格第一行横跨所有列)

---

## JS逻辑运算

>**题号**:0004
>
>**来源**:OPPO
>
>**知识点**: JS的逻辑与和逻辑或
>
>**时间**：2024-07-28

此代码的运行结果为

```js
console.log(0&&1,0||1,1&&3,1||3)
```

![](0004.png)

>**正确答案**:A
>
>**官方解析**:
>
>再进行&&和||运算时，两边的语句会转化为布尔类型（Boolean），然后再进行运算，本题中，
>
>&&和||两边均为数字，非0数字转化为true，0转化为false。
>
>&&是两边都是true，结果才是true；||是任意有一个true结果就为true。
>
>第一个表达式结果为false，返回0。
>
>第二个表达式结果为true，返回1，D选项排除。
>
>第三个表达式为true，因为&&需判断两个值都true，所以返回第二个为真的值3，C选项错误。
>
>第四个表达式为true，因为||只判断一个值为true就是true，所以返回第一个为真的值1。
>
>A选项是正确的。

对于JS的逻辑与(&&)和逻辑或(||),如果两边均为数字,则非0数字为true,0为false

$逻辑运算\begin{cases}\&\&\begin{cases}第一位为0->返回0\\第一位为true\begin{cases}第二位为0->返回0\\第二位为true->返回第二位的值\end{cases}\end{cases}\\逻辑或\begin{cases}第一位为0->返回第二位\\第一位为true->返回第一位\end{cases}\end{cases}$

---

## 循环结构访问数组

>**题号**：0005
>
>**来源**：OPPO
>
>**知识点**：循环结构
>
>**时间**: 2024-07-28

此代码的运行结果为()

```js
var arr = [1,2,5,7,8]
for(var i=0;i<arr.length;i++){
    for(var j=0;j<arr.length;j++){
        if(arr[i]+arr[j] == 12){
            console.log(i,j)
        }
    }
}
```

![](0005.png)

>**正确答案**:D
>
>**官方解析**:
>
>此代码用双重for循环遍历数组，当两个元素的和为12时，将两个元素的下标输出。
>
>从数组中可知，5+7的和为12。 因为是双重for循环，第一层循环到5第二层循环到7时，会执行if语句块，第一层循环到7第二层循环到5时，也会执行if语句，所以会输出两次，AB选项排除。
>
>if 语句块中输出的变量i , j 分别可看做数组元素的下标，所以输出的值应为2 3；3 2，D选项正确。

---

## JS的Promise

>**题号**：0006
>
>**来源**：OPPO
>
>**知识点**：JS的Promise
>
>**时间**: 2024-07-28

请问一下JS代码输出的结果是()

```js
const p1 = Promise.resolve(117)
const p2 = Promise.resolve(p1)
const p3 = Promise.resolve(117)
console.log(p1==p2,p1===p2,p1===p3)
```

![](0006.png)

>**正确答案**:A
>
>**官方解析**:
>
>Promise.resolve方法如果传入一个非Promise、非thenable的立即值，则得到的是以这个值填充的Promise，即使这个值一样，得到的也不是相同的Promise，所以p1不等于p3，选项BC错误。
>
>Promise.resolve方法如果传入一个真正的Promise，那么返回的就是这个Promise本身，所以p1和p2是同一个Promise，选项D错误。
>
>所以最终输出的结果是true、true、false，选项A正确。

**什么是Promise**

- Promise A+规范:
  - 出现在ES6(2015年)之前
  - 是一个民间规范
  - 主要解决异步处理问题
  - 该规范解释Promise对象为:带有then方法的对象
  - 规定了一个带then方法的对象到底满足什么规则才能进行异步处理
- ES6的Promise
  - 吸纳了Promise A+ 规范
  - 可以使用构造函数方法`const p = new Promise()`来得到一个符合Promise A+ 规范的对象
  - 引入了一些新的方法
    - catch
    - finally
    - all
    - race
    - allsettled 

**GPT整理内容**

JavaScript 中的 `Promise` 是一种处理异步操作的方式，它提供了一种比传统的回调函数更优雅的方式来处理异步流程中的成功和失败情况。Promise 对象代表了一个最终可能会完成或失败的异步操作，并且一旦状态改变就不会再变回原来的状态。

**Promise 的基本概念**

一个 Promise 对象有三种状态：
1. **Pending（等待中）**：初始状态，既不成功也不失败。
2. **Fulfilled（已成功）**：表示异步操作成功完成。
3. **Rejected（已失败）**：表示异步操作失败。

一旦 Promise 变成 Fulfilled 或 Rejected 状态，它的状态就不会再改变，这种特性被称为“不可变性”。

**创建 Promise**

创建 Promise 实例的基本语法如下：

```javascript
const promise = new Promise((resolve, reject) => {
  // 异步操作
  if (/* 异步操作成功 */) {
    resolve(value); // 成功时调用 resolve 函数
  } else {
    reject(error); // 失败时调用 reject 函数
  }
});
```

`resolve` 和 `reject` 是 Promise 构造函数接收的执行器函数的参数。执行器函数会在 Promise 创建后立即执行。

**使用 Promise**

`.then()` 方法

`.then()` 方法用来注册成功回调函数。如果 Promise 成功，`.then()` 中的回调函数会被调用。

```javascript
promise.then(result => {
  console.log('成功: ', result);
});
```

`.catch()` 方法

`.catch()` 方法用来注册失败回调函数。如果 Promise 失败，`.catch()` 中的回调函数会被调用。

```javascript
promise.catch(error => {
  console.error('错误: ', error);
});
```

`.finally()` 方法

`.finally()` 方法无论 Promise 最终是成功还是失败都会执行。

```javascript
promise
  .then(result => {
    console.log('成功: ', result);
  })
  .catch(error => {
    console.error('错误: ', error);
  })
  .finally(() => {
    console.log('清理工作');
  });
```

**Promise 的链式调用**

Promise 支持链式调用，这意味着你可以连续地使用 `.then()`、`.catch()` 和 `.finally()` 方法来处理多个异步操作。

```javascript
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log('数据: ', data);
    return data.processed; // 假设 data 对象有一个 processed 属性
  })
  .then(processedData => {
    console.log('处理后的数据: ', processedData);
  })
  .catch(error => {
    console.error('请求错误: ', error);
  });
```

**Promise 的静态方法**

除了实例方法之外，Promise 类还提供了一些静态方法，用于处理多个 Promise：

- **`.all()`**：等待所有 Promise 完成，并返回一个包含所有结果的数组。
- **`.race()`**：返回一个 Promise，该 Promise 会解析或拒绝第一个完成的 Promise。
- **`.allSettled()`**：等待所有 Promise 完成，并返回一个对象数组，每个对象表示每个 Promise 的最终状态。
- **`.any()`**：返回一个 Promise，该 Promise 会在任何一个 Promise 成功时解析，或者在所有 Promise 都失败时拒绝。

这些静态方法可以非常方便地处理多个异步操作。

**示例**

下面是一个简单的示例，演示如何使用 Promise：

```javascript
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const randomValue = Math.random();
      if (randomValue > 0.5) {
        resolve(`Success: ${randomValue}`);
      } else {
        reject(new Error(`Error: ${randomValue}`));
      }
    }, 1000);
  });
};

fetchData()
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

以上就是一个关于 JavaScript 中 Promise 的简要介绍。Promise 提供了一种强大而灵活的方式来管理异步代码，使得程序更加易于理解和维护。

---

## JS代理

>**题号**：0007
>
>**来源**：OPPO
>
>**知识点**：JS的代理
>
>**时间**: 2024-07-28

请问一下JS 代码最终输出结果是（）

```js
const obj = {
    flag: 'Jhon',
    func: function(){
        console.log(this)
        console.log(this.flag)
    }
}
const p = new Proxy(obj,{})
p.func()
obj.func()
```

![](0007.png)

>**正确答案**:B
>
>**官方解析**:
>
>Proxy可以代理针对目标对象的访问，但它不是目标对象的透明代理，且在Proxy代理的情况下，目标对象内部的this关键字会指向Proxy代理，则p.func函数返回的this指向是Proxy，选项D错误。
>
>Proxy代理了对象obj，尽管this指向改变了，但是flag属性是保存在对象obj下，依然可以访问到目标对象obj下的flag属性，输出Jhon。当然，有些原生对象如Date的内部属性则可能因为this指向改变而无法取到值，选项A错误。
>
>Proxy代理后作用于变量p，原对象obj并没有受到影响，因此obj.func函数可以正常的输出this指向即自身、属性flag的值Jhon，选项C错误。
>
>所以代码最终的结果是Proxy {flag: 'Jhon', func: ƒ}、Jhon、{flag: 'Jhon', func: ƒ}、Jhon，选项B正确。

---

## 计算机网络香农公式

>**题号**：0008
>
>**来源**：OPPO
>
>**知识点**：计算机网络中的香农公式
>
>**时间**: 2024-07-28

现已知信噪比为30dB,信道带宽为8kHz,则该信道的信道容量大约为()

![](0008.png)

>**正确答案**:D
>
>**官方解析**:
>
>
>根据香农公式：![img](https://www.nowcoder.com/equation?tex=C%3DW*log2(1%2B%5Cfrac%7BS%7D%7BN%7D)(bit%2Fs))，W为信道带宽，单位为Hz，S是信号功率（瓦），N是噪声功率（瓦）。
>
>信噪比![img](https://www.nowcoder.com/equation?tex=SNR(%E4%BF%A1%E5%99%AA%E6%AF%94%EF%BC%8C%E5%8D%95%E4%BD%8D%E4%B8%BAdB)%3D10log10%5E%7B%5Cfrac%7BS%7D%7BN%7D%7D)，代入公式得![img](https://www.nowcoder.com/equation?tex=%5Cfrac%7BS%7D%7BN%7D%3D10%5E%7B%5Cfrac%7BSNR%7D%7B10%7D%7D%3D10%5E%7B%5Cfrac%7B30%7D%7B10%7D%7D%3D1000)，
>
>![img](https://www.nowcoder.com/equation?tex=C%3D8*1000*log2%5E%7B(1%2B1000)%7D%3D80000(bit%2Fs)%3D80000%2F1000%3D80kbps)

---

## 操作系统文件存储

>**题号**：0009
>
>**来源**：OPPO
>
>**知识点**：操作系统中的文件
>
>**时间**: 2024-07-28

如果一个磁盘块的大小是100字符,一文件中的第0到第99字符位于第5个磁盘块上,那么第280到300的字符位于第几号磁盘块上()

![](0009.png)

>**正确答案**:B
>
>**官方解析**:
>
>考查操作系统中的文件。
>
>一个磁盘块的大小是100字符，一文件中的第0到99的字符位于第5个磁盘块上，那么第280到300的字符位于![img](https://www.nowcoder.com/equation?tex=5%2B250%2F100%3D7)号磁盘块上

---

## JS严格模式，数组的arguments

>**题号**：0010
>
>**来源**：OPPO
>
>**知识点**：arguments对象,严格模式
>
>**时间**: 2024-07-28

![](0010.png)

>**正确答案**:C
>
>**官方解析**:
>
>在严格模式下，不论参数如何变化，arguments 对象都不会随之改变，因此严格模式下输出应为 true、false，选项 AD 错误。
>
>在非严格模式下，命名参数的变化会同步更新到 arguments 对象中，也就是说变量 a 的值与 arguments[0] 始终保持一致，输出应为 true、true，选项 B 错误。
>
>所以代码最终输出的结果分别为 true、false 和 true、true，选项 C 正确。

**arguments对象**

1. **`arguments` 对象**: `arguments` 是一个类数组对象，它包含了函数调用时传入的所有参数。在函数内部，可以通过 `arguments[0]` 来访问第一个参数。
2. **变量赋值**: 当你在一个函数内部声明一个变量并对其进行赋值时，这个变量的值只会影响这个局部变量本身。在非严格模式下，如果你在函数内部对一个未声明的变量进行赋值，它会被视为全局变量。在严格模式下，这样做会导致一个引用错误。

---

## 计算机网络UDP传输

>**题号**：0011
>
>**来源**：OPPO
>
>**知识点**：计算机网络中的UDP传输
>
>**时间**: 2024-07-28

UDP属于尽力而为的不可靠传输,使用UDP传输的数据,其可靠性需要在那一层保证?

![](0011.png)

>**答案**:D
>
>**官方解析**:
>
>UDP是一个无连接的、不可靠的传输层协议，如果用户采用UDP传输数据，必须在传输层的上层提供可靠性保证的工作，表示层只负责转化数据的表现形式，因此只能是应用层保证可靠性，选D。

---

## 计算机网络GBN协议

>**题号**：0012
>
>**来源**：OPPO
>
>**知识点**：可靠性传输的保证方法:停止等待,回退N帧,选择重传
>
>**时间**: 2024-07-28

主机A与主机B建立了一条TCP协议，采用的是GBN重传方式。假如发送窗口是3，在时刻t，接收方期待的下一个有序分组的序号是 k，请问这个时刻发送方窗口内的报文序号可能是多少？(假设接受主机不会对报文重新排序)

![](0012.png)

>**正确答案**:B
>
>**官方解析**:
>
>首先我们需要抓住关键--GBN协议，然后反应出GBN协议几个特点：发送方拥有一个窗口，长度为N=3；接收方无窗口，只接收希望接受序号的报文，对于失序到达的报文段采取的方式是直接丢弃；在重传的时候，将会重传当前发送方窗口中所有未被确认的报文段。在t时刻，接收方起到收到的下一个分组序号为k，说明接收方已经正确接受了k之前的所有分组，对于发送方而言，我们考虑两种最极端的情况：
>第一种情况：假设之前所有的报文都正确传输，没有任何丢失的问题，那么在这种情况下，发送方正确接收了接收方对于小于k的所有报文的ACK确认，因此窗口将会不断向后移动，序号为k、k+1、k+2；
>
>第二种情况：由已知条件我们可以得知序号为k-1的报文是发送方发送的最后一个报文，假设该报文虽然到达了接收方，但是接收方返回的ACK确认由于一些原因没有到达发送方，则窗口不会移动，在这种情况下我们再假设序号k-1位于窗口的最后一列，即如下图所示的所有序号报文都没有在发送方被确认，则得到了我们最坏的一种情况，k-3、k-2、k-1；
>
>综合上述两种情况，[k-3, k+2]区间内的都可能出现，因此选B。

---

## Linux命令home

>**题号**：0013
>
>**来源**：OPPO
>
>**知识点**：Linux命令
>
>**时间**: 2024-07-28

Linux 中，假设当前用户 zhangsan 所在目录为 /home，则想要切换到 zhangsan 的家目录 /home/zhangsan 下，则下面命令不能实现的是（）

![](0013.png)

>**正确答案**:B
>
>B选项中,cd /zhangsan 会去根目录下查早zhangsan故无法切换

---

## Linux命令basename

>**题号**：0014
>
>**来源**：OPPO
>
>**知识点**：Linux命令
>
>**时间**: 2024-07-28

Linux中,执行以下命令的结果是()

```bash
basename /etc/sysconfig/network
```

![](0014.png)

在 Linux 中，`basename` 命令用于从给定的路径中移除目录名，只返回文件名部分。当你运行 `basename /etc/sysconfig/network` 时，该命令将返回路径中的最后一部分，即文件名。

---

## 数据结构与算法：前中后缀表达式

>**题号**：0015
>
>**来源**：OPPO
>
>**知识点**：前中后缀表达式的转化
>
>**时间**: 2024-07-28

中缀表达式`a*b+c/d-e`的前缀表达式是:()

![](0015.png)

中缀表达式变为前缀表达式,将每一个运算都加上括号,然后将运算符移到自己的括号前面即可.

---

## 操作系统进程调度算法

>**题号**：0016
>
>**来源**：OPPO
>
>**知识点**：操作系统进程调度算法
>
>**时间**: 2024-07-29

下面哪种进程调度算法可能导致优先级进程饥饿：（）

![](0016.png)

## 编程题：进度环

>**题号**：0017
>
>**来源**：OPPO
>
>**知识点**：svg图像
>
>**时间**: 2024-07-29

实现一个进度环，当页面输入框中输入对应百分比，进度环动画展示当前百分比。效果如下图：

1. 在输入框中输入0-100的数据，点击更新进度按钮，圆环动画展示当前所占比例。
2. 当在输入框中输入数据超出0-100范围，不再继续往下运行函数，返回null

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      .progress-ring {
        width: 200px;
        height: 200px;
        position: relative;
      }
 
      .progress-ring .circle {
        fill: none;
        stroke: #ddd;
        stroke-width: 20;
      }
 
      .progress-ring .progress {
        fill: none;
        stroke: #0d7137;
        stroke-width: 20;
        stroke-dasharray: 0, 1000;
        stroke-linecap: round;
        transition: stroke-dasharray 0.5s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div class="progress-ring">
      <svg viewBox="0 0 100 100">
        <circle class="circle" cx="50" cy="50" r="40"></circle>
        <circle class="progress" cx="50" cy="50" r="40"></circle>
      </svg>
    </div>
    <input
      type="number"
      id="percentageInput"
      placeholder="输入百分比（0-100）"
    />
    <button onclick="updateProgress()">更新进度</button>
 
    <script>
      function updateProgress() {
        const percentageInput = document.getElementById('percentageInput')
        const percentage = parseInt(percentageInput.value, 10)
        /*--1. 补全代码，当输入的数据不是数字，或者超出【0,100】,当前函数返回null-----*/
        if (!percentage || percentage < 0 || percentage > 100) return null
 
        const progressRing = document.querySelector('.progress-ring')
        const progressCircle = progressRing.querySelector('.progress')
        const circumference = 2 * Math.PI * 40
 
        /*--2. 补全代码，根据输入的百分比设置圆环样式-----*/
        const offset = circumference*percentage/100
        progressCircle.style.strokeDasharray = `${offset} 1000`
      }
    </script>
  </body>
</html>
```

---

## 数据结构与算法:哈夫曼树

>**题号**：0018
>
>**来源**：OPPO
>
>**知识点**：哈夫曼树
>
>**时间**: 2024-07-29

若以{3, 6, 9, 12, 15, 18, 21, 24, 27}作为叶子结点的权值构造一棵哈夫曼树，则其带权路径长度是（ ）

![](0018.png)

画出哈夫曼树如下图:

![](哈夫曼树有背景.jpg)

由图像可知,该哈夫曼树的带权路径长度为

$27*2+(21+24+18+12+15)*3+9*4+(3+6)*5\\=54+270+36+45\\=405$

---

## 数据结构与算法:二分查找

>**题号**：0019
>
>**来源**：OPPO
>
>**知识点**：二分查找
>
>**时间**: 2024-08-15

已知一个有序表（2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26），当二分查找值为15的元素时，若采取向上取整的方式取中间值，查找成功的比较次数为（ ）

![](0019.png)

总共13个元素

- 第一次比较:`mid = (1+13)/2=7`,第7位是14,14<15
- 第二次比较`mid = (7+13)/2=10`,第10位是20,20>15
- 第三次比较`mid = (7+10)/2=8.5`,向上取整为9,第9位是18,18>15
- 第四次比较`mid = (7+9)/2=8`,第8位是16>15

此时若15存在,则应该在第7位和第8位之间,而实际上,他俩之间没有元素,故判断15不在数组中.

---

## CSS的Flex布局

>**题号**：0020
>
>**来源**：OPPO
>
>**知识点**：Flex布局
>
>**时间**: 2024-08-15

要实现一个左侧宽度固定,右侧元素自适应,应该在下面代码中补充哪个选项()

```html
<div class="container">
<div class="fixed-width">固定宽度</div>
<div class="flexible-width">自适应宽度</div>
</div>
.container {
display: flex;
}
.fixed-width {
width: 200px; /* 左边元素的固定宽度 */
}
.flexible-width {
/* 在此补全代码 */
}
```

![](0020.png)

---

>**题号**：0021
>
>**来源**：OPPO
>
>**知识点**：散列存储
>
>**时间**: 2024-07-28

## 数据结构与算法:散列(哈希)存储

已知一组关键字为 {21, 32, 43, 57, 61, 74, 85}，采用链地址法处理冲突，散列表是一个下标从0开始的长度为12的一维数组，散列函数为 H(key) = key MOD 12，则装填因子 α 是（）。

![](0021.png)

因为采用链地址法处理冲突,所以每一个关键字都会存储在散列表中,装填因子$\alpha = \frac{关键字数量}{散列表长度}=\frac{7}{12}$,存储情况如下图.

![](散列存储.png)

---

## 数据结构与算法:数组奇数

>**题号**：0022
>
>**来源**：OPPO
>
>**知识点**:数组的奇数
>
>**时间**: 2024-07-28

小欧有一个长度为 n*n* 的数组，现在他想挑出 3 个数，使得这 3 个数的和为奇数，如果可以挑出则输出 "YES"，否则输出 "NO"

```js
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;
 
void (async function () {   
    // Write your code here
    //获取数组长度
    let n = await readline();
    //获取整个数组
    let string = await readline();
    let array = string.split(" ").map((item) => parseInt(item));
    //如果只有3个数，则必须只有1个奇数，或者3个全为奇数
    if (n == 3) {
        let odd = 0;
        for (let i = 0; i < n; i++) {
            if (array[i] % 2 !== 0) {
                odd++;
            }
        }
        console.log(odd === 1 || odd === 3 ? "YES" : "NO");
    }
    //如果大于3个数，只要有1个奇数就可以
    else {
        let odd = 0;
        for (let i = 0; i < n; i++) {
            if (array[i] % 2 !== 0) {
                odd++;
                console.log("YES");
                break;
            }
        }
        if (!odd) console.log("NO");
    }
})();
```

---

## 数据结构与算法：子数组和
>**题号**：0023
>
>**来源**：OPPO
>
>**知识点**：子数组和的最大公约数
>
>**时间**: 2024-07-28

小欧有一个长度为 n*n* 的数组，他需要把这个数组分割成 k(k>1)*k*(*k*>1) 个非空子数组，也就是 [l1,r1],[l2,r2],⋯ ,[lk,rk][*l*1,*r*1],[*l*2,*r*2],⋯,[*l**k*,*r**k*]，其中 1≤l1<r1≤l2<r2≤⋯≤lk<rk≤n1≤*l*1<*r*1≤*l*2<*r*2≤⋯≤*l**k*<*r**k*≤*n*，并且 ri+1=li+1*r**i*+1=*l**i*+1。

对于每个子数组，小欧都会计算出这个子数组的总和 bi=ali+⋯+ari*b**i*=*a**l**i*+⋯+*a**r**i*。

现在小欧想找一个分割方案（子数组数量 k*k* 必须大于 1），使得 gcd⁡(b1,…,bk)gcd(*b*1,…,*b**k*) 最大，请你帮他找到最大值。

gcd：指最大公约数，Greatest Common Divisor的缩写。

暂时不会



# 58集团 23届秋招正式批

## 最短送餐路径

暂时不会

## 最长无重复子串

>**题号**：0002
>
>**来源**：58集团
>
>**知识点**：队列的应用
>
>**时间**: 2024-09-09

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 *
 * @param str string字符串
 * @return string字符串
 */
function filterMaxStr( str ) {
    // write code here
    let left = 0 	// 左指针
    let ans = '' 	// 返回结果
    let window = new Set() // 定义一个滑动窗口(队列),left到right指针的字符
    // 遍历字符串
    for(let right=0;right<str.length;right++){
        // 当窗口中已经有right指向的字符时
        // 则需要左移left将窗口缩小，直至字符移出窗口
        while(window.has(str[right])){
            window.delete(str[left++])
        }
        // 将right所指的字符加入窗口中
        window.add(str[right])
        // 如果当前子串长度超过上一次的子串，则取当前的
        if(right-left+1>ans.length){
            ans = str.slice(left,right+1)
        }
    }
    return ans
}
module.exports = {
    filterMaxStr : filterMaxStr
};
```

## 反转数组元素

>**题号**：0003
>
>**来源**：58集团
>
>**知识点**：反转数组，双指针，解构赋值
>
>**时间**: 2024-09-09

不要使用数组的reverse 方法，反转一下数组的元素。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 反转数组的字符串
 * @param s string字符串一维数组 字符串数组
 * @return string字符串一维数组
 */
function reverseString( s ) {
    // write code here
    let start = 0
    let end = s.length-1
    // 遍历交换
    while(start<end){
        // 解构赋值
        [s[start],s[end]]=[s[end],s[start]]
        // 指针移动
        start++
        end--
    }
    return s
}
module.exports = {
    reverseString : reverseString
};
```

## Cookie和Storage

>**题号**：0004
>
>**来源**：58集团
>
>**知识点**：Cookie和Storage
>
>**时间**: 2024-09-09

![](58集团0004.png)

>**题号**：0018
>
>**来源**：58集团
>
>**知识点**：Cookie和Storage
>
>**时间**: 2024-09-09

![](58集团0018.png)

## 移动端融合技术

>**题号**：0005
>
>**来源**：58集团
>
>**知识点**：PWA,severless,hybird app, ts,flutter
>
>**时间**: 2024-09-09

![](58集团0005.png)

## 箭头函数

>**题号**：0006
>
>**来源**：58集团
>
>**知识点**：箭头函数不能做构造函数
>
>**时间**: 2024-09-09

下段代码打印结果为：

```js
const Person = (name="wang",age=10) => {
  this.name = name;
  this.age = age;
  return this.name +' is '+ this.age + 'years old'
}
let result = new Person('zhang',11)
console.log(result)
```

![](58集团0006.png)

>**题号**：0020
>
>**来源**：58集团
>
>**知识点**：箭头函数,const变量声明,this指针上下文
>
>**时间**: 2024-09-09

以下输出结果

```js
const a = 10;
const obj = {
    a: 20,
    console: ()=>{
        var a = 30;
        console.log(this.a)
    }
}
obj.console()
```

![](58集团0020.png)

>**题号**：0023
>
>**来源**：58集团
>
>**知识点**：箭头函数,const变量声明,this指针上下文
>
>**时间**: 2024-09-09

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，以下差异说明错误的是：

![](58集团0023.png)



- 箭头函数没有独立的{%label this,arguments 和 super绑定 green%},并且不可被用作{%label 方法green%}
- 箭头函数不能用作{%label 构造函数 green%}.使用{%label new green%}调用它们会引发{%label TypeError green%}.它们也无法访问{%label new.target green%}关键字.
- 箭头函数不能在其主体中使用{%label yield green%},也不能作为生成器函数创建.
- 参数部分支持{%label 剩余参数,默认参数,解构赋值 green%},并且始终需要使用括号

```js
(a,b,...r) => expression
(a = 400, b = 20, c) => expression
([a,b] = [10,20]) => expression
({a,b}={a:10,b:20}) => expression
```

- 箭头函数可以是{%label async green%}的,方法就是在表达式前加上`async`关键字

```js
async param => expression
async (param1, param2, ...paramN) => {
    statements
}
```

- 当函数只有一个简单参数时,参数的括号可以省略.
- 当函数直接返回表达式时,函数体大括号和`return`关键字可以省略.
- 箭头函数总是未命名的.如果箭头函数需要调用自身,需要使用具名函数表达式.也可以将箭头函数赋值给一个变量,这样它就有了名字.

```js
const bob2 = a => a + 100
```

>**注意**
>
>当使用表达式体语法`(params)=>{object: literal}`返回对象字面量时,不能按预期工作

```js
const func = ()=>{foo: 1}
// 调用func()会返回undefined!

const func2 = ()=>{foo: function(){} }
// SyntaxError: function statement requires a name

const func3 =()=>{ foo(){}}
// SyntaxError: Unexpected token'{'
```

这是因为只有当箭头后面的标记不是左括号时,JS才会将箭头函数视为表达式体,因此括号({})内的代码会被解析为一系列语句,其中`foo`是{%label 标签 green%},而不是对象文字中的键.

要解决这个问题,可以用括号将对象字面量包装起来.

```js
const func = ()=>({foo: 1})
```

- 不能用作方法

箭头函数表达式只能用于非方法函数,因为它们没有自己的`this`.让我们看看将它们用作方法时会发生什么

```js
"use strict" 
const obj = {
    i: 10,
    b: ()=> console.log(this.i,this),
    c() {
        console.log(this.i,this)
    }
}

obj.b()		// 输出 undefined, Window{/* ... */}(或全局对象)
obj.c()		// 输出 10, Object {/* ... */}
```

另一个示例涉及到`Object.defineProperty()`

```js
"use strict"

const obj = {
    a: 10
}
Object.defineProperty(obj,"b",{
    get:()=>{
        console.log(this.a,typeof this.a,this)
        // undefined 'undefined' Window {/* ... */}
        return this.a + 10
        // 代表全局对象'Window',故'this.a'返回'undefined',this.a+10返回NaN
    }
})
```

由于{%label 类 green%}体具有`this`上下文,因此作为{%label 类字段 green%}的箭头函数会关闭类的`this`上下文,箭头函数体中的`this`将正确指向示例(对于静态字段来说就是类本身).但是,由于它是一个{%label  闭包  green%},而不是函数本身的绑定,因此`this`的值不会根据执行上下文而改变.

```js
class C {
    a = 1;
    autoBoundMethod=()=>{
        console.log(this.a)
    }
}
const c = new C()
c.autoBoundMethod()  // 1
const { autoBoundMethod } = c
autoBoundMethod()	// 1
// 如果这是普通方法,此时应该是undefined
```

箭头函数属性通常被称作"自动绑定方法",因为它与普通方法的等价性相同:

```js
// 这段代码暂时还不理解
class C {
    a = 1;
    constructor() {
        this.method = this.method.bind(this)
    }
    method() {
        console.log(this.a)
    }
}
```

{%label 以下内容暂时不理解  red%}

>备注
>
>类字段是在实例(instance)上定义的,而不是在原型(prototype)上定义的,因此每次创建实例都会创建一个新的函数引用并分配一个新的闭包,这可能会导致比普通非绑定方法更多的内存使用.

出于类似的原因,`call()`,`apply()`,`bind()`方法在箭头函数上调用时不起作用,因为箭头函数根据箭头函数定义的作用域来建立`this`的,而`this`的值不会根据函数的调用方式而改变.

- 没有参数绑定

箭头函数没有自己的`arguments`对象.因此,在本例中,`arguments`是对外层作用域参数的引用.

```js
function foo(n) {
    const f = ()=>arguments[0] + n; // foo的隐式参数绑定.arguments[0]为n
    return f();
}

foo(3) // 3 + 3 = 6
```

>**注意**
>
>严格模式下不能声明名为`arguments`的变量,因此上面的代码会出现语法错误.这使得`arguments`的范围效应更容易理解.

在大多数情况下,使用{%label 剩余参数 green%}是比使用`arguments`对象更好的选择.

```js
function foo(n) {
    const f = (...args)=>args[0]+n
    return f(10)
}

foo(1)  // 11
```

- 不能用作构造函数

箭头函数不能用作构造函数,当使用`new`调用时会出错.它们也没有`prototype`属性.

```js
const Foo = () =>{}
const foo = new Foo() // TypeError: Foo is not a constructor
console.log("prototype" in Foo) //false
```

- 不能用作生成器

箭头函数的主体中不能使用`yield`关键字(除非在箭头函数进一步嵌套的生成器函数中使用).

因此,箭头函数不能用作生成器.

- 箭头前换行

箭头函数的参数和箭头之间不能换行

```js
const func = (a,b,c)
	=> 1
// SyntaxError: Unexpected token '=>'
```

为便于格式化,可在箭头后换行,或在函数体周围使用括号/花括号,如下图所示.也可以在参数之间换行.

```js
const func = (a, b, c) =>
  1;

const func2 = (a, b, c) => (
  1
);

const func3 = (a, b, c) => {
  return 1;
};

const func4 = (
  a,
  b,
  c,
) => 1;
```

- 箭头的优先级

虽然箭头函数中的箭头不是运算符,但与普通函数相比,箭头函数具有特殊的解析规则,与运算符优先级的交互方式不同.

{%label 这是错误示范 red%}

```js
let callback;
callback = callback || ()=>{}
// SyntaxError: invalid arrow-function arguments
```

由于`=>`的优先级低于大多数运算符,因此需要使用括号来避免`callback || ()`被解析为箭头函数的参数列表

{%label 以下是正确内容 green%}

```js
callback = callback || (()=>{})
```



## HTTP报文头字段

以下与http缓存无关的头字段是:

![](58集团0007.png)

常用HTTP标头

- Content-Length

  - 类型: Forbidden header name(禁止修改的标头)
  - 语法 :`Content-Length:  <length>`
  - 指令: `<length>`消息的长度,用十进制数字表示的字节的数目

- ETag

  - `Etag`HTTP响应头是资源的特定版本的标识符.这可以让缓存更高效,并节省带宽,因为如果内容没有改变,Web服务器不需要发送完整的响应.而如果内容发生了变化,使用Etag有助于防止资源的同时更新相互覆盖('空中碰撞')
  - 如果给定URL中的资源更改,则一定要生成新的`ETag`值.比较这些`Etag`能快速确定此资源是否变化.
  - 类型: Forbidden header name
  - 语法: 

  ```http
  ETag: W/"<etag_value>"
  ETag: "<etag_value>"
  ```

  - 指令

    - `W/`（可选，大小写敏感)表示使用{%label 弱验证器 green%}.弱验证器很容易生成，但不利于比较。强验证器是比较的理想选择，但很难有效地生成。相同资源的两个弱`ETag`值可能语义等同，但不是每个字节都相同。
    - `<etag_value>
  
    实体标签唯一地表示所请求的资源。他们是位于双引号之间的ASCII字符串(如"675af34563dc-tr34").没有明确指定生成ETag值得方法。通常，使用内容得散列，最后修改时间戳得哈希值，或简单地使用版本号。
  
  - 避免“空中碰撞”
  
  在`ETag`和`If-Match`头部的帮助下，可以检测到“空中碰撞”的编辑冲突。
  
  例如，当编辑MDN时，当前的wiki内容被散列，并在响应中放入`ETag`
  
  ```http
  ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
  ```
  
  将更改保存到Wiki页面(发布数据时),`POST`请求将包含有ETag值得`If-Match`头来检查是否为最新版本。
  
  ```http
  If-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
  ```
  
  如果哈希值不匹配,则意味着文档已经被编辑,抛出`412`前提条件失败错误.
  
  - 缓存为更改的资源
  
  `ETag`头得另一个典型用例是缓存未更改得资源.如果用户再次访问给定的URL(设有`ETag`字段),显示资源过期了且不可用,客户端就发送值为`ETag`的`If-None-Math`header字段.
  
  ```http
  If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
  ```
  
  服务器将客户端的`ETag`(与`If-None-Match`一起发送)与其当前版本的资源的`ETag`进行比较,如果两个值匹配(即资源未更改),服务器将返回不带任何内容的`304` `Not Modified`状态,告诉客户端缓存版本可用(fresh).
  
- Expires

  - `Expires`响应标头包含响应应被视为过期的日期/时间
  - 无效的日期(比如0)代表过去的日期,即该资源已经过期.
  
  >**注意**
  >
  >如果响应中有指令为`max-age`或`s-maxage`的`Cache-Control`标头,则`Expires`标头会被忽略.
  
  - 语法
  
  ```http
  Expires: <http-date>
  ```
  
  - 指令: `<http-date>`,HTTP日期时间戳
  - 示例:
  
  ```http
  Expires: Wed, 21 Oct 2015 07:28:00 GMT
  ```
  
  

- Last-Modified

  - `Last-Modified`是一个响应首部,其中包含源头服务器认定的资源作出修改的日期及时间.它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致.由于精确度比`ETag`低,所以这是一个备用机制.包含有`If-Modified-Since`或`If-Unmodified-Since`首部的条件请求会使用这个字段.
  - 语法

  ```http
  Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
  ```

  - 指令
    - `<day-name>`:"Mon","Tue","Wed","Thu","Fri","Sat"或"Sun"之一(区分大小写)
    - `<day>`:两位数字表示的天数,例如"04"or"23"
    - `<month>`"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"之一(区分大小写)
    - `<year>`:4位数字表示的年份,例如"1990"或者"2016"
    - `<hour>`:2位数字表示的小时数,例如"09"或者"23"
    - `<minute>`:两位数字表示的分钟数,例如"04"或者"59"
    - `GMT`:国际标准时间.HTTP中的时间均用国际标准时间表示,从来不适用当地时间.
  - 示例

  ```http
  Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
  ```

## 回流(重排)与重绘

>**题号**：0009
>
>**来源**：58集团
>
>**知识点**：CSS重绘和回流
>
>**时间**: 2024-09-09

以下哪一项不能最小化重绘(repaint)和回流(reflow)：

![](58集团0009.png)



## CSS注释

>**题号**：0011
>
>**来源**：58集团
>
>**知识点**：CSS重绘和回流
>
>**时间**: 2024-09-10

在.css文件中，以下CSS 代码注释正确的是？

![](58集团0011.png)

>**注意**
>
>- Vue的`<style>`标签中可以使用//来注释
>- 但是CSS文件中,或者原生html的`<style>`标签中只能使用/*.. */来注释



## CSS继承

>**题号**：0012
>
>**来源**：58集团
>
>**知识点**：CSS重绘和回流
>
>**时间**: 2024-09-10

以下哪个CSS属性可以被继承？

![](58集团0012.png)

在CSS中,每个CSS属性定义的概述都指出了这个属性是默认继承的("Inherited:yes")还是默认不继承的("Inherited: no").这决定了当你没有为元素的属性指定值时该如何计算值.

`inherit`关键字允许显式地声明继承性,它对继承和非继承属性都生效.

可以使用`all`简写属性一次控制所有属性的继承,该属性将其值应用于所有属性.

```css
font {
    all: revert;
    font-size: 200%;
    font-weight: bold;
}
```

这会将`font`属性的样式恢复为用户代理(浏览器)的默认值,除非存在用户样式表,在这种情况下使用该样式表.然后它将字体大小加倍并应用font-weight为bold.

## HTML 的a标签和标签语义化

>**题号**：0013
>
>**来源**：58集团
>
>**知识点**：a标签属性
>
>**时间**: 2024-09-10

针对以下的html代码,描述正确的是

```html
<a href="#code1" target="_blank" onclick="javascript: return false">code1</a>
```

![](58集团0013.png)

>**题号**：0014
>
>**来源**：58集团
>
>**知识点**：HTML语义化
>
>**时间**: 2024-09-10

关于HTML语义化，以下哪个说法是正确的

![](58集团0014.png)

## 正则表达式

>**题号**：0016
>
>**来源**：58集团
>
>**知识点**：正则表达式
>
>**时间**: 2024-09-10

以下代码块执行结果是

```js
console.log('AABCA'.replace('AB','a'))
console.log('AABCA'.replace(/[AB]/,'a'))
```

![](58集团0016.png)                                          

第一行代码表示搜索字符串中的模式"AB",并替换为a,故结果为AaCA

第二行代码表示搜索字符串中的模式"A"或"B",由于没有全局匹配,故只匹配到第一个A,将其替换为'a',结果为aABCA

## JS相等性判断

>**题号**：0008
>
>**来源**：58集团
>
>**知识点**：相等判断
>
>**时间**: 2024-09-10

以下表达式,结果为true的是:

![](58集团0008.png)

A. 加法运算符（`+`）为两种不同的运算重载：数字加法和字符串连接。在求值时，它首先[将两个操作数强制转换为基本类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#强制原始值转换)。然后，检查两个操作数的类型：

- 如果有一方是字符串，另一方则会被[转换为字符串](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String#字符串强制转换)，并且它们连接起来。
- 如果双方都是 [BigInt](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt)，则执行 BigInt 加法。如果一方是 BigInt 而另一方不是，会抛出 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)。
- 否则，双方都会被[转换为数字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number#number_强制转换)，执行数字加法。

所以左边为'3'+'2'='32',故结果为false

B. true是布尔值,宽松比较中转化为数字1,两边不相等

C. [Number 强制转换](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number#number_强制转换)

许多期望数值的内置操作首先将其参数转换为数字（这在很大程度上解释了为什么 `Number` 对象的行为类似于数字原始值）。[该操作](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumber)可以总结如下：

- Number 将按原样返回
- [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined) 转换为 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)。
- [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null) 转换为 `0`。
- `true` 转换为 `1`；`false` 转换为 `0`。
- 字符串将被假定为包含数字字面量，并通过解析它们来转换。解析失败会得到`NaN`.与实际数字字面量相比，它们有一些细微的差别：
  - 前导和尾随的空格/换行符会被忽略。
  - 前导的数字 `0` 不会导致该数值成为八进制字面量（或在严格模式下被拒绝）。
  - `+` 和 `-` 允许出现在字符串的开头以指示其符号。（在实际代码中，它们“看起来像”文字的一部分，但实际上是独立的一元运算符。）然而，该标志只能出现一次，并且后面不能跟空格。
  - `Infinity` 和 `-Infinity` 被当作是字面量。在实际代码中，它们是全局变量。
  - 空字符串或仅包含空格的字符串转换为 `0`。
  - 不允许使用[数字分隔符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#数值分隔符)。
- [BigInt](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt) 抛出 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)，以防止意外的强制隐式转换导致精度损失。
- [Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol) 抛出 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)。
- 对象首先通过按顺序调用它们的 [`[Symbol.toPrimitive]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)（使用 `"number"` 提示）、`valueOf()` 和 `toString()` 方法将其[转换为原始值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#强制原始值转换)。然后将得到的原始值转换为数字。

有两种方法可以在 JavaScript 中实现几乎相同的效果。

- [一元加](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Unary_plus)：`+x` 完全按照上面的数值强制转换步骤来转换 `x`。
- [`Number()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/Number) 函数：`Number(x)` 使用相同的算法转换 `x`，除了 [BigInt](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt) 不会抛出 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)，而是返回其数字值，并且可能导致精度损失。

[`Number.parseFloat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat) 和 [`Number.parseInt()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt) 与 `Number()` 相似，但只能转换字符串，并且解析规则略有不同。例如，`parseInt()` 无法识别小数点，`parseFloat()` 无法识别 `0x` 前缀。

这里的'a',转换为数字是NaN,NaN和任何东西都不宽松相等,包括它自己.所以返回false;

D. 左侧是布尔上下文.在 [JavaScript](https://developer.mozilla.org/zh-CN/docs/Glossary/JavaScript) 中，**真值**是在[布尔值](https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean)上下文中，转换后的值为 `true` 的值。被定义为[假值](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)以外的任何值都为真值。（即所有除 `false`、`0`、`-0`、`0n`、`""`、`null`、`undefined` 和 `NaN` 以外的皆为真值）。

所以[]是真值,转化为布尔值为true,用!取逻辑后结果为false.布尔值和其他值进行宽松相等比较时,布尔值转换为数字,false转换为0.

至此,左边为0,右边为空字符串'',字符串转化为数字,''变成0,故相等.

>**题号**：0010
>
>**来源**：58集团
>
>**知识点**：相等判断
>
>**时间**: 2024-09-10

```js
const a = ([]) ? true:false;
const b = []==false? true:false;
const c = ({}==false)? true:false;
```

a,b,c的值分别是什么?

![](58集团0010.png)

A. 用()括起来空数组[],是布尔上下文,[]值为true

B. []与false进行宽松相等判断,[]是对象,要转换为原始值,没有内置的[Symbol.toPrimitive]方法,valueOf()方法返回地是数组本身,故调用toString()方法,转换为空字符串"",然后就是空字符串""与布尔值宽松比较,布尔值false转换为数字0,然后是空字符串与数字0宽松比较,空字符串转化为数字0,两者相等.故为true

C. 空对象{}与原始值false宽松比较,{}转换为原始值.[Symbol.toPrimitive]方法和valueOf()方法无效,toString()方法返回一个字符串"[object Object]",第一个小写的object表示这是一个对象,第二个Object表示的是对象的构造函数名称.然后是false转化为0.

然后是字符串"[object Object]"转换为数字,是NaN,故结果为false

>**题号**：0015
>
>**来源**：58集团
>
>**知识点**：相等判断
>
>**时间**: 2024-09-10

以下四行代码的执行结果分别是

```js
undefined == null
0 = NaN
'' == 0
'' == null
```

![](58集团0015.png)

A. undefine和null只有另一边也是undefined或null时,才宽松相等,其他都不相等.故A为true

B.NaN和任何东西都不宽松相等,故B为false

C.空字符串转换为数字0,相等,返回true

D.参见A,故返回false

JavaScript提供三种不同的值比较运算:

- `===`严格相等
- `==`宽松相等
- `Object.is()`

要根据需要进行选择

- 在比较两个操作数时,双等号(`==`)将执行类型转换,并且会按照IEEE 754 标准对`NaN`,`-0`,`+0`进行特殊处理(故`NaN!=NaN`,且`-0==+0`)
- 三等号(`===`)做的比较与双等号相同(包括对`NaN`,`-0`,`+0`的特殊处理,但不进行类型转换.如果类型不同,则返回`false`)
- `Object.is()`既不进行类型转换,也不对`NaN`,`-0`和`+0`进行特殊处理(这使它和`===`在除了哪些特殊数字值之外的情况具有相同的表现)

上述三个操作分别与JavaScript中的四个相等算法中的三个对应:

- IsLooselyEqual(`==`)
- isStrictlyEqual(`===`)
- SameValue(`Object.is()`)
- SameValueZero:被许多内置运算使用

请注意,这些算法的区别都在与它们对原始类型值得处理有关.它们都不会比较参数是否具有理论上相似的结构.{%label 对于任何具有相同的结构,但不是同一对象本身的非原始类型对象`x`和`y`,上述所有形式都将计算为`false`  red%}

- 使用===进行严格相等比较

严格相等比较两个值是否相等。两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不相等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值相等。最后，如果两个值都是 number 类型，当两个都不是 `NaN`，并且数值相同，或是两个值分别为 `+0` 和 `-0` 时，两个值被认为是相等的。

```js
const num = 0;
const obj = new String("0");
const str = "0";

console.log(num === num); // true
console.log(obj === obj); // true
console.log(str === str); // true

console.log(num === obj); // false
console.log(num === str); // false
console.log(obj === str); // false
console.log(null === undefined); // false
console.log(obj === null); // false
console.log(obj === undefined); // false
```

在日常中使用严格相等几乎总是正确的选择。对于除了数值之外的值，严格相等使用明确的语义进行比较：一个值只与自身严格相等。对于数值，严格相等使用略加修改的语义来处理两个特殊情况：第一个情况是，浮点数 0 是不分正负的。区分 `+0` 和 `-0` 在解决一些特定的数学问题时是必要的，但是大部分情况下我们并不用关心。严格相等认为这两个值是全等的。第二个情况是，浮点数包含了 `NaN` 值，用来表示某些定义不明确的数学问题的解，例如：正无穷加负无穷。严格相等认为 `NaN` 与其他任何值都不全等，包括它自己。（等式 `(x !== x)` 成立的唯一情况是 `x` 的值为 `NaN`）

除了 `===` 之外，数组索引查找方法也使用严格相等，包括 [`Array.prototype.indexOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)、[`Array.prototype.lastIndexOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf)、[`TypedArray.prototype.index()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/indexOf)、[`TypedArray.prototype.lastIndexOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf) 和 [`case`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/switch) 匹配。这意味着你不能使用 `indexOf(NaN)` 查找数组中 `NaN` 值的索引，也不能将 `NaN` 用作 `case` 值在 `switch` 语句中匹配任何内容。

```js
console.log([NaN].indexOf(NaN)); // -1
switch (NaN) {
  case NaN:
    console.log("Surprise"); // 没有任何输出
}
```

- 使用==进行宽松相等

宽松相等是{%label 对称的 green%}:对于任何`A`和`B`的值,`A==B`总是与`B==A`具有相同的语义(除了转换应用的顺序).使用`==`执行宽松相等的行为如下:

1. 如果操作数具有相同的类型,则按如下方式进行比较:
   - 对象(Object):仅当两个操作数引用同一个对象时返回`true`
   - 字符串(String):仅当两个操作数具有相同的字符且顺序相同时返回`true`
   - 数字(Number): 如果两个操作数的值相同，则返回`true`,`+0`和`-0`被视为相同的值。如果任何一个操作数是`NaN`，则返回`false`。`NaN`永远不等于任何值,包括自己.
   - 布尔值(Boolean):仅当操作数都为`true`或都为`false`时返回`true`
   - 大整型(BigInt): 仅当两个操作数的值相同时返回`true`
   - 符号(Symbol):仅当两个操作数引用相同的符号时返回`true`
   
2. 如果其中一个操作数为`null`或`undefined`,另一个操作数也必须为`null`或`undefined`以返回`true`,否则返回`false`

3. 如果其中一个操作数是对象,另一个是原始值,则{%label 对象转换为原始值 green%}.

   - 对象将依次调用它的`[Symbol.toPrimitive]()`(将`default`作为`hint`值),`valueOf()`和`toString()`方法.

   - >- 原始值强制转换
     >   - [Symbol.toPrimitive]\("default")
     >   - valueOf()
     >   - toString()
     >- 数字类型强制转换,number,BigInt
     >   - [Symbol.toPrimitive]\("number")
     >   - valueOf()
     >   - toString()
     >- 字符串类型强制转换
     >   - [Symbol.toPrimitive]\("string")
     >   - toString()
     >   - valueOf()

4. 在这一步,两个操作数都被转换为原始值(字符串,数字,布尔值,符号和大整型其中的一个).剩余的转换将分情况完成.

   - 如果是相同的类型,使用步骤1进行比较
   - 如果其中一个操作数是符号而另一个不是,返回`false`
   - 如果其中一个操作数是布尔值而另一个不是,则`将布尔值转换为数字`: true转换为1,false转换为0然后再对两个操作数进行宽松比较.
   - 数字与字符串:{%label 将字符串转换为数字 green %}.转换失败将导致`NaN`,这将保证相等比较为`false`
   - 数字与大整型:按数值进行比较.如果数字的值为正负∞或`NaN`,返回`false`
   - 字符串与大整型:使用与`BigInt()`构造函数相同的算法将字符串转换为大整型数.如果转换失败,返回`false`

   一般而言,根据ECMAScript规范,所有原始类型和对象都不与`undefined`和`null`宽松相等.

## 判断Array

![](58集团0017.png)



## 变量声明,闭包,作用域

>**题号**：0019
>
>**来源**：58集团
>
>**知识点**：箭头函数,const变量声明,this指针上下文
>
>**时间**: 2024-09-19

![](58集团0019.png)

**三种变量声明**

- `const`声明用于声明块作用域的局部变量。常量的值不能通过使用{%label 赋值运算符 green%}重新赋值来更改,但是如果常量是一个对象,它的属性可以被添加,更新或删除.

  - const声明的作用域既可以是块级作用域,也可以是函数作用域.
  - const声明只有在声明的位置之后才能访问,因此,const声明通常被视为{%label 非提升 green%}的声明方式.
  - 当在脚本的顶层声明时,const声明不会再`globalThis`上创建属性
  - 在同一作用域中,const声明不能被任何其他声明{%label 重新声明 green%}.
  - const 是声明而不是语句.这意味着你不能将单独的const声明用作块的主体.

  ```js
  if(true) const a = 1;
  // SyntaxError: Lexical declaration cannot appear in a single-statement context
  ```

  一个常量需要一个初始值.你必须在声明同时指定它的值.

  ```js
  const FOO; 
  // SyntaxError: Missing initializer in const declaration
  ```

  >**const本质是声明地址不变的量**

- let

  - let声明用于声明可以重新赋值的块级作用域局部变量,并且可以选择将其初始化为一个值.
  - let声明的变量只能在执行到声明所在的位置之后才能被访问
  - let声明在脚本的顶级作用域上声明变量时不会在`globalThis`上创建属性
  - let声明的变量不能被同一个作用域中的任何其他声明重复声明.

  **暂时性死区**

  用 `let`、`const` 或 `class` 声明的变量可以称其从代码块的开始一直到代码执行到变量声明的位置并被初始化前，都处于一个“暂时性死区”（Temporal dead zone，TDZ）中。

  当变量处于暂时性死区之中时，其尚未被初始化，并且任何访问其的尝试都将导致抛出 [`ReferenceError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)。当代码执行到变量被声明的位置时，变量会被初始化为一个值。如果变量声明中未指定初始值，则变量将被初始化为 `undefined`。

  这与 [`var`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#变量提升) 声明的变量不同，如果在声明位置前访问 `var` 声明的变量会返回 `undefined`。以下代码演示了在声明位置前访问 `let` 和 `var` 声明的变量的不同结果。

  ```js
  {
      // 暂时性死区始于作用域开头
      console.log(bar);	// 'undefined'
      console.log(foo);	// ReferenceError: Connot access 'foo' before initialization
      var bar = 1;
      let foo = 2;	// 暂时性死区结束(对foo而言)
  }
  ```

  使用“暂时性”一词是因为这个区域取决于代码执行的时间点，而不是代码编写的顺序。例如，下面的代码能够运行，是因为虽然使用 `let` 变量的函数写在变量声明之前，但函数是在暂时性死区外面被*调用*的。

  ```js
  {
      // 暂时性死区始于作用域开头
      const func = () => console.log(letVar); // 没问题
      
      // 在暂时性死区访问letVar会抛出'ReferenceError'
      
      let letVar = 3; // 暂时性死区结束(对letVar而言)
      func();	// 在暂时性死区外调用
  }
  ```

  >**备注：** `let` 和 `const` 声明仅在当前脚本被处理时才会被处理。如果在一个 HTML 中有两个以脚本模式运行的 `<script>` 元素，那么第一个脚本不会受到第二个脚本中顶层 `let` 或 `const` 变量的暂时性死区限制，尽管如果你在第一个脚本中声明了一个 `let` 或 `const` 变量，在第二个脚本中再次声明它将会导致[重复声明错误](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let#重复声明)。

  ### [作用域规则](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let#作用域规则)

  `let` 声明的变量的作用域只在其声明的块或子块内部，在这一点上，它与 `var` 非常相似。二者之间主要的区别在于 `var` 声明的变量的作用域是整个闭合的函数。

  ```js
  function varTest() {
    var x = 1;
    {
      var x = 2; // 同一个变量！
      console.log(x); // 2
    }
    console.log(x); // 2
  }
  
  function letTest() {
    let x = 1;
    {
      let x = 2; // 不同的变量
      console.log(x); // 2
    }
    console.log(x); // 1
  }
  ```

  在程序的顶级作用域和函数作用域中，`let` 则和 `var` 不一样，它不会在全局对象上创建属性。例如：

  ```js
  var x = "global";
  let y = "global";
  console.log(this.x); // "global"
  console.log(this.y); // undefined
  ```

  

- var语句用于声明一个{%label 函数作用域或全局作用域 green%} 的变量,并且可以选择将其初始化为一个值.

  - 用 `var` 声明的变量的作用域是最靠近并包含 `var` 语句的以下花括号闭合语法结构的一个：

    - 函数主体
    - 类[静态初始化块](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks)

    如果不是以上这些情况则是：

    - 当前[模块](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)，如果代码以模块模式运行
    - 全局作用域，如果代码以脚本模式运行

  - ```js
    function foo() {
    	var x = 1;
        function bar() {
            var y = 2;
            console.log(x); // 1('bar'函数闭包中引用了'x')
            console.log(y); // 2('y'在作用域内)
        }
        bar();
        console.log(x);  //1('x'在作用域内)
        console.log(y);	 //ReferenceError,'y'的作用域限定在'bar'内
    }
    foo();
    ```

  - 重要的是，其他块级结构，包括[块语句](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/block)、[`try...catch`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch)、[`switch`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/switch) 以及[其中一个 `for` 语句的头部](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements#迭代)，对于 `var` 并不创建作用域，而在这样的块内部使用 `var` 声明的变量仍然可以在块外部被引用。

  - ```js
    for (var a of [1, 2, 3]);
    console.log(a); // 3
    ```

  - [提升](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#提升)

    `var` 声明，无论它们出现在脚本中的什么位置，都会在执行脚本中的任何代码之前进行处理。在代码中的任何位置声明变量都相当于在顶部声明它。这也意味着变量可以在其声明之前被使用。这种行为被称为[*提升*](https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting)，因为变量声明似乎被移动到发生该行为的函数、静态初始化块或脚本源代码的顶部。

    **备注：** `var` 声明仅提升到当前脚本的顶部。如果在一个 HTML 文件中有两个 `<script>` 元素，则第一个脚本无法访问第二个脚本声明的变量，直到第二个脚本已被处理和执行。

  - [重新声明](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#重新声明)

    即使是在严格模式下，使用 `var` 重复声明变量不会触发错误，变量的值也不会丢失，除非新的声明有初始化器。

    ```js
    var a = 1;
    var a = 2;
    console.log(a); // 2
    var a;
    console.log(a); // 2; not undefined
    ```

    `var` 可以与 `function` 在同一作用域中声明同名变量。在这种情况下，`var` 声明的初始化器总是会覆盖函数的值，而无论它们的相对位置如何。这是因为函数声明会提升到作用域的顶部，而初始化器会在其后才被求值，因此会覆盖函数的值。

    ```js
    var a = 1;
    function a() {}
    console.log(a); // 1
    ```

    `var` 不能与 [`let`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let)、[`const`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const)、[`class`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class) 或 [`import`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import) 在同一作用域中声明同名变量。

**闭包**

闭包(closure)是一个函数以及其捆绑的周边环境状态(lexical environment, 词法环境)的引用的组合.换而言之,闭包让开发者可以从内部函数访问外部函数的作用域.在JS中,闭包会随着函数的创建而被同时创建.

- 词法作用域

  - 请看下面的代码

  - ```js
    function init() {
        var name = 'Mozilla';	//name是一个被init创建的局部变量
        function displayName() {
            // displayName()是内部函数,一个闭包
            alert(name);	//使用了父函数中声明的变量
        }
        displayName();
    }
    init();
    ```

    - `init()`创建了一个局部变量`name`和一个名为`displayName()`的函数.`displayName()`是定义在`init()`里的内部函数,并且仅在`init()`函数体内可用.请注意,`displayName()`没有自己的局部变量.然而,因为它可以访问到外部函数的变量,所以,`displayName()`可以使用父函数`init()`中声明的变量`name`

- 闭包

  - ```js
    function makeFunc() {
        var name = "Mozilla";
        function displayName() {
            alert(name);
        }
        return displayName();
    }
    var myFunc = makeFunc();
    myFunc();
    ```

  - 运行这段代码的效果和之前`init()`函数的示例完全一样.其中不同的地方(也是有意思的地方)在于内部函数`displayName()`在执行前,从外部函数返回.

  - 第一眼看上去,也许蹦年直观地看出这段代码能够正常运行.在一些变成语言中,一个函数中的局部变量仅存在于此函数的执行期间.一旦`makeFunc()`执行完毕,你可能会认为`name`变量将不能再被访问.然而,JS中情况显然与此不同.

  - 原因在于,JS中的函数会形成了闭包.闭包是由函数以及声明该函数的词法环境组合而成的.该环境包含了这个闭包创建时作用域内的任何局部变量.在本例子中,`myFunc`是执行`makeFunc`时创建的displayName函数实例的引用.`displayName`的实例维持了一个对它的词法环境(变量`name`存在于其中)的引用.因此,当`myFunc`被调用时,变量`name`仍然可用,其值`Mozilla`就被传递到`alertz`中.

  - 下面有一个更有意思的示例,一个`makeAdder`函数:

  - ```js
    function makeAdder(x) {
        return functionK(y) {
            return x + y;
        }
    }
    var add5 = makeAdder(5);
    var add10 = makeAdder(10);
    
    console.log(add5(2));	//7
    console.log(add10(2));	//12
    ```

  - 在这个示例中，我们定义了 `makeAdder(x)` 函数，它接受一个参数 `x` ，并返回一个新的函数。返回的函数接受一个参数 `y`，并返回`x+y`的值。

    从本质上讲，`makeAdder` 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。

    `add5` 和 `add10` 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 `add5` 的环境中，`x` 为 5。而在 `add10` 中，`x` 则为 10。

  - 闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。

    因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。

    在 Web 中，你想要这样做的情况特别常见。大部分我们所写的 JavaScript 代码都是基于事件的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常作为回调：为响应事件而执行的函数。

    假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 `body` 元素的 `font-size`，然后通过相对的 `em` 单位设置页面中其他元素（例如`header`）的字号：

    ```css
    body {
        font-family: Helvetica,Arial,sans-serif;
        font-size: 12px;
    }
    h1 {
        font-size: 1.5em;
    }
    h2 {
        font-size: 1.2em;
    }
    ```

    我们的文本尺寸调整按钮可以修改 `body` 元素的 `font-size` 属性，由于我们使用相对单位，页面中的其他元素也会相应地调整。

    以下是 JavaScript：

    ```js
    function makeSizer(size) {
        return function() {
            document.body.style.fontSize = size + 'px';
        };
    }
    var size12 = makeSizer(12);
    var size14 = makeSizer(14);
    var size16 = makeSizer(16);
    ```

  - 用闭包模拟私有方法

  编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其他方法所调用。

  而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。

  下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为[模块模式（module pattern）](https://www.google.com/search?q=javascript+module+pattern)：

  ```js
  var Counter = (function () {
    var privateCounter = 0;
    function changeBy(val) {
      privateCounter += val;
    }
    return {
      increment: function () {
        changeBy(1);
      },
      decrement: function () {
        changeBy(-1);
      },
      value: function () {
        return privateCounter;
      },
    };
  })();
  
  console.log(Counter.value()); /* logs 0 */
  Counter.increment();
  Counter.increment();
  console.log(Counter.value()); /* logs 2 */
  Counter.decrement();
  console.log(Counter.value()); /* logs 1 */
  ```

  在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：`Counter.increment`，`Counter.decrement` 和 `Counter.value`。

  该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 `privateCounter` 的变量和名为 `changeBy` 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。

  这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 `privateCounter` 变量和 `changeBy` 函数。

  >**备注：**你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量`Counter`。我们可以把这个函数储存在另外一个变量`makeCounter`中，并用他来创建多个计数器。

  ```js
  var makeCounter = function () {
    var privateCounter = 0;
    function changeBy(val) {
      privateCounter += val;
    }
    return {
      increment: function () {
        changeBy(1);
      },
      decrement: function () {
        changeBy(-1);
      },
      value: function () {
        return privateCounter;
      },
    };
  };
  
  var Counter1 = makeCounter();
  var Counter2 = makeCounter();
  console.log(Counter1.value()); /* logs 0 */
  Counter1.increment();
  Counter1.increment();
  console.log(Counter1.value()); /* logs 2 */
  Counter1.decrement();
  console.log(Counter1.value()); /* logs 1 */
  console.log(Counter2.value()); /* logs 0 */
  ```

  请注意两个计数器 `Counter1` 和 `Counter2` 是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量 `privateCounter` 。

  每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。

## 对象遍历的数据类型于顺序

>**题号**：0021
>
>**来源**：58集团
>
>**知识点**：对象属性遍历
>
>**时间**: 2024-09-19

![](58集团0021.png)

**`Object.keys()`** 静态方法返回一个由给定对象自身的可枚举的字符串键属性名组成的数组。

`Object.keys()` 返回一个数组，其元素是{%label 字符串 red%} ，对应于直接在对象上找到的可枚举的字符串键属性名。这与使用 [`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环迭代相同，只是 `for...in` 循环还会枚举原型链中的属性。`Object.keys()` 返回的数组顺序和与 [`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环提供的顺序相同。

根据现代 ECMAScript 规范的定义，遍历的顺序是一致且可预测的。在原型链的每个组件中，所有非负整数键（可以作为数组索引）将首先按值升序遍历，然后是其他字符串键按属性创建的先后顺序升序遍历。

在题目所示对象中,2,0,1,均为非负整数键,所以它们先升序排列.之后是空字符串.

## 对象转原始值

![](58集团0022.png)

四个选项的共同点是都要进行三次宽松相等的判断,分别是和数字1,2,3.而a不是原始值,所以要转换为原始值.数组是一种对象,对象转换为原始值,优先调用[Symbol.toPrimitive]方法,其次是valueOf(),最后是toString()

A.将a.toString()设置为a.shift(),即返回数组首位元素.所以依次为1,2,3,三次判断均为true,打印1

B.设置a的[Symbol.toPrimitive]方法为一个立即执行函数,该立即执行函数是一个箭头函数,参数i传入值设置为0,该立即执行函数返回结果是另一个箭头函数,该箭头函数没有参数,返回结果是立即执行函数的参数值的处理:++i,

即先将i+1,再返回.所以依次返回1,2,3.

C. 类似A,自定义了valueOf()函数

D.该选项涉及到生成器函数，这里应该调用this.gn.next().value才可以获取yield里面的值。

`function*`声明创建一个绑定到给定名称的新生成器函数.生成器函数可以退出,并在稍后重新进入,其上下文(变量绑定)会在重新进入时保存.

>**备注：**箭头函数不能用来定义生成器函数。
>
>**备注：** `function` 和 `*` 是两个单独的标记，因此它们可以用[空白或换行符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#空白符)分隔。

`function*` 声明创建一个 [`GeneratorFunction`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction) 对象。每次调用生成器函数时，它都会返回一个新的 [`Generator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator) 对象，该对象符合[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#迭代器协议)。当迭代器的 `next()` 方法被调用时，生成器函数的主体会被执行，直到遇到第一个 [`yield`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield) 表达式，该表达式指定了迭代器要返回的值，或者用 [`yield*`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield*) 委托给另一个生成器函数。`next()` 方法返回一个对象，其 `value` 属性包含了 `yield` 表达式的值，`done` 属性是布尔类型，表示生成器是否已经返回了最后一个值。如果 `next()` 方法带有参数，那么它会恢复生成器函数的执行，并用参数替换暂停执行的 `yield` 表达式。

在 JavaScript 中，生成器——尤其是与 Promises 结合使用时——是一种非常强大的异步编程工具，它们解决了回调函数存在的一些的问题，如[回调地狱](http://callbackhell.com/)和[控制反转](https://frontendmasters.com/courses/rethinking-async-js/callback-problems-inversion-of-control/)。然而，通过使用[异步函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function)，我们可以更简单地解决这些问题。

在生成器中执行 `return` 语句会使生成器结束（即返回的对象的 `done` 属性将被设置为 `true`）。如果返回一个值，它将被设置为生成器返回的对象的 `value` 属性。与 `return` 语句类似，如果生成器内部抛出错误，生成器也会结束，除非在生成器的代码体内捕获该错误。当生成器结束后，后续 `next()` 调用不会执行生成器的任何代码，只会返回一个形如 `{value: undefined, done: true}` 的对象。

`function*` 声明的行为与 [`function`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function) 声明类似——它们会被[提升](https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting)到其作用域的顶部，并且可以在当前作用域的任何位置被调用，且只能在特定的上下文中被重新声明。

简单示例

```js
function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const gen = idMaker();

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
// …
```

使用yield*示例

```js
function* anotherGenerator(i) {
  yield i + 1;
  yield i + 2;
  yield i + 3;
}

function* generator(i) {
  yield i;
  yield* anotherGenerator(i);
  yield i + 10;
}

const gen = generator(10);

console.log(gen.next().value); // 10
console.log(gen.next().value); // 11
console.log(gen.next().value); // 12
console.log(gen.next().value); // 13
console.log(gen.next().value); // 20
```

传入参数给生成器

```js
function* logGenerator() {
  console.log(0);
  console.log(1, yield);
  console.log(2, yield);
  console.log(3, yield);
}

const gen = logGenerator();

// next 的第一次调用从函数的开头开始执行，直到第一个 yield 语句
gen.next(); // 0
gen.next("pretzel"); // 1 pretzel
gen.next("california"); // 2 california
gen.next("mayonnaise"); // 3 mayonnaise
```

生成器中的返回语句

```js
function* yieldAndReturn() {
  yield "产生的值";
  return "返回的值";
  yield "不会被访问到的值";
}

const gen = yieldAndReturn();
console.log(gen.next()); // { value: "产生的值", done: false }
console.log(gen.next()); // { value: "返回的值", done: true }
console.log(gen.next()); // { value: undefined, done: true }
```

生成器作为对象属性

```js
const someObj = {
  *generator() {
    yield "a";
    yield "b";
  },
};

const gen = someObj.generator();

console.log(gen.next()); // { value: 'a', done: false }
console.log(gen.next()); // { value: 'b', done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

生成器作为对象方法

```js
class Foo {
  *generator() {
    yield 1;
    yield 2;
    yield 3;
  }
}

const f = new Foo();
const gen = f.generator();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```


---
title: 笔试真题
date: 2024-07-25 16:27:53
tags: 刷题
categories: 刷题笔记
top_img: 顶部图.jpg
cover: 缩略图.jpg
---
# OPPO 24届秋招正式批笔试

>**考点分析**

![](考点分析.png)

## CSS权重

>**题号**：0001
>
>**来源**：OPPO
>
>**知识点**：css权重分析
>
>**时间**: 2024-07-25

执行以下程序，对于①②式能否在a标签上实现效果，下列说法正确的是（）

```html
div {

        width:200px;

        height: 200px;

        text-decoration: none; ...①

        font-size:12px; ...②

}

<div class="father">

      <a href = "#">跳转</a>

</div>
```

![](0001.png)

>**正确答案**:D
>
>**官方题解**:
>
>text-decoration和font-size都是定义在a的父级元素上，通过让a元素继承这两个属性来实现效果。事实上，这两个属性都是可继承的，但不同的是，a标签自身还有默认属性text-decoration和color，该默认样式的权重比继承的高（继承的权重为0），因此①式并没有在a标签上起效果，而a标签的默认样式属性中没有font-size，因此②式可以起效果。



在CSS中，元素的样式可以被多个规则所影响。当这些规则发生冲突时，浏览器需要决定哪个规则应该优先应用。这就涉及到CSS中的“权重”（或称为“特异性”）概念。

**CSS权重的基本原则**

CSS权重是根据选择器的不同类型来计算的，权重值越高，则该选择器的优先级越高。权重由高到低分为四个等级：

1. **内联样式** (`style` 属性)：权重为 1000。

   - 例如：`<p style="color: red;">This text is red.</p>`

2. **标识符选择器** (`#id`)：每个标识符选择器权重为 100。

   - 例如：`#myID { color: blue; }`

3. **类选择器** (`.class`)、属性选择器 (`[attribute]`) 和伪类 (`:hover`, `:first-child` 等)：每个类选择器、属性选择器或伪类的权重为 10。

   - 例如：

     ```
     .myClass { color: green; }
     ```

     - 或者：`a:hover { color: yellow; }`

4. **类型选择器** (`element`) 和伪元素 (`::before`, `::after` 等)：每个类型选择器或伪元素的权重为 1。

   - 例如：

     ```
     p { color: orange; }
     ```

     - 或者：`p::first-letter { color: purple; }`

5. **通用选择器** (`*`, `div`, `p` 等)、子代选择器 (`>`), 相邻同胞选择器 (`+`), 一般同胞选择器 (`~`) 和伪关键字 `:not()` 的权重为 0。

   - 例如：

     ```
     * { color: black; }
     ```

     - 或者：`div > p { color: gray; }`

6. **继承** 和 **用户代理样式表** 的权重为 0，但它们具有默认优先级。

   - 浏览器默认的样式。

7. **`!important` 标志**：在样式声明后加上 `!important` 可以提高权重，其权重高于所有其他权重，但低于内联样式中的 `!important`。

   - 例如：`p { color: blue !important; }`

**计算权重的步骤**

- 对于一个给定的选择器，计算每个级别的权重总和。
- 如果两个选择器的权重相同，则离元素更近的选择器优先（更具体的上下文）。
- 如果权重仍然相同，最后声明的规则将优先（CSS的层叠规则）。

**示例**

假设我们有以下CSS规则：

1. `p { color: blue; }` （权重为 1）
2. `.redText { color: red; }` （权重为 10）
3. `#special { color: green; }` （权重为 100）

如果一个段落同时使用了类 `.redText` 和 ID `#special`，那么最终的颜色将是绿色，因为 ID 选择器的权重更高。

**复杂选择器**

当选择器包含多个部分时，将每个部分的权重相加。例如，`#myID .myClass` 的权重为 100 + 10 = 110。

**总结**

理解CSS权重可以帮助你更好地控制页面样式的优先级，避免不必要的覆盖和冲突。尽量避免过度使用高权重的选择器（如 `!important`），因为它可能会导致样式难以管理和维护。

---

## CSS属性


>**题号**：0002
>
>**来源**：OPPO
>
>**知识点**：行内元素和块级元素
>
>**时间**: 2024-07-25

![](0002.png)

>**正确答案**:B
>
>**官方解析**:vertical-align在行内元素中设置有效，在块级元素中设置无效，即使块级元素嵌套了行内元素，行内元素也不会继承块级元素的该属性，故B选项符合要求；ACD选项均在块级元素中设置有效，作用在块级元素内的文本等内容。

---

## BFC(Block Formatting Context)

>**题号**:0003
>
>**来源**:OPPO
>
>**知识点**:BFC
>
>**时间**：2024-07-28

执行一下程序，当给main盒子添加overflow:hidden；则变化情况为

```html
<style>
.box {
        width: 200px;
        height: 300px;
}
.sideBar {
        float: left;
        width: 50px;
        height: 100px;
}
.main {
        height: 200px;
}
</style>
<div class="box">
        <div class="sideBar"></div>
        <div class="main"></div>
</div>
```

![](0003.png)

>**正确答案**:B
>
>**官方解析**:
>
>添加前，由于sideBar盒子设置了浮动，因此main盒子会移动并占据sideBar盒子的位置，结果是main盒子紧贴在sideBar盒子的左边，添加后，overflow:hidden触发产生新的bfc。根据bfc的布局规则，bfc区域不会与浮动元素的区域发生重叠，因此，main盒子会紧贴在sideBar盒子的右边。

**常规流,块盒**

1. 水平方向上,撑满整个包含块宽度,垂直方向上,依次摆放
2. 垂直方向上相邻的元素,margin会合并(取两者中的最大值)
3. 父子关系的情况下,可能会产生margin塌陷
4. 父子关系的情况下,父元素无视浮动元素会产生高度坍塌
5. 兄弟关系的情况下,正常元素可能会被浮动元素覆盖(正常元素在浮动元素之后)

**BFC**(Block Formatting Context)区块格式化上下文

1. 开启BFC的区域,是一块{%label 独立的渲染区域 green%}
2. {%label 隔绝了内部与外部的联系 green%},内部渲染不会影响到外部
3. 不同的BFC区域,{%label 渲染时也互不干扰 green%}

**开启BFC能解决什么问题**

1. 开启BFC，其{%label 子元素 green%}不会再产生margin塌陷问题(不会和他的子元素产生margin合并)
2. 开启BFC，就算子元素浮动，{%label 自身高度也不会坍塌 green%}(计算高度时不再无视浮动元素)
3. 开启BFC，{%label 自己不会被其他浮动元素所覆盖 green%}(不会与浮动元素重叠，会避开浮动元素排布)

**如何开启BFC**

1. 根元素(HTML)自身是一个BFC
2. 设置{%label float green%}属性
3. 设置{%label position green%}属性为设置{%label absolute或fixed green%}
4. 设置{%label overflow green%}属性值{%label 不为visible green%}
5. 行内块盒({%label inline-block green%})
6. 设置{%label display green%}为{%label flow-root green%}的元素
7. 伸缩项目({%label flex盒子内的item green%})
8. 多列容器(设置{%label column-count green%})
9. 表格元素(table thead tbody tfoot tr th td caption)
10. column-span为all的元素(表格第一行横跨所有列)

---

## JS逻辑运算

>**题号**:0004
>
>**来源**:OPPO
>
>**知识点**: JS的逻辑与和逻辑或
>
>**时间**：2024-07-28

此代码的运行结果为

```js
console.log(0&&1,0||1,1&&3,1||3)
```

![](0004.png)

>**正确答案**:A
>
>**官方解析**:
>
>再进行&&和||运算时，两边的语句会转化为布尔类型（Boolean），然后再进行运算，本题中，
>
>&&和||两边均为数字，非0数字转化为true，0转化为false。
>
>&&是两边都是true，结果才是true；||是任意有一个true结果就为true。
>
>第一个表达式结果为false，返回0。
>
>第二个表达式结果为true，返回1，D选项排除。
>
>第三个表达式为true，因为&&需判断两个值都true，所以返回第二个为真的值3，C选项错误。
>
>第四个表达式为true，因为||只判断一个值为true就是true，所以返回第一个为真的值1。
>
>A选项是正确的。

对于JS的逻辑与(&&)和逻辑或(||),如果两边均为数字,则非0数字为true,0为false

$逻辑运算\begin{cases}\&\&\begin{cases}第一位为0->返回0\\第一位为true\begin{cases}第二位为0->返回0\\第二位为true->返回第二位的值\end{cases}\end{cases}\\逻辑或\begin{cases}第一位为0->返回第二位\\第一位为true->返回第一位\end{cases}\end{cases}$

---

## 循环结构访问数组

>**题号**：0005
>
>**来源**：OPPO
>
>**知识点**：循环结构
>
>**时间**: 2024-07-28

此代码的运行结果为()

```js
var arr = [1,2,5,7,8]
for(var i=0;i<arr.length;i++){
    for(var j=0;j<arr.length;j++){
        if(arr[i]+arr[j] == 12){
            console.log(i,j)
        }
    }
}
```

![](0005.png)

>**正确答案**:D
>
>**官方解析**:
>
>此代码用双重for循环遍历数组，当两个元素的和为12时，将两个元素的下标输出。
>
>从数组中可知，5+7的和为12。 因为是双重for循环，第一层循环到5第二层循环到7时，会执行if语句块，第一层循环到7第二层循环到5时，也会执行if语句，所以会输出两次，AB选项排除。
>
>if 语句块中输出的变量i , j 分别可看做数组元素的下标，所以输出的值应为2 3；3 2，D选项正确。

---

## JS的Promise

>**题号**：0006
>
>**来源**：OPPO
>
>**知识点**：JS的Promise
>
>**时间**: 2024-07-28

请问一下JS代码输出的结果是()

```js
const p1 = Promise.resolve(117)
const p2 = Promise.resolve(p1)
const p3 = Promise.resolve(117)
console.log(p1==p2,p1===p2,p1===p3)
```

![](0006.png)

>**正确答案**:A
>
>**官方解析**:
>
>Promise.resolve方法如果传入一个非Promise、非thenable的立即值，则得到的是以这个值填充的Promise，即使这个值一样，得到的也不是相同的Promise，所以p1不等于p3，选项BC错误。
>
>Promise.resolve方法如果传入一个真正的Promise，那么返回的就是这个Promise本身，所以p1和p2是同一个Promise，选项D错误。
>
>所以最终输出的结果是true、true、false，选项A正确。

**什么是Promise**

- Promise A+规范:
  - 出现在ES6(2015年)之前
  - 是一个民间规范
  - 主要解决异步处理问题
  - 该规范解释Promise对象为:带有then方法的对象
  - 规定了一个带then方法的对象到底满足什么规则才能进行异步处理
- ES6的Promise
  - 吸纳了Promise A+ 规范
  - 可以使用构造函数方法`const p = new Promise()`来得到一个符合Promise A+ 规范的对象
  - 引入了一些新的方法
    - catch
    - finally
    - all
    - race
    - allsettled 

**GPT整理内容**

JavaScript 中的 `Promise` 是一种处理异步操作的方式，它提供了一种比传统的回调函数更优雅的方式来处理异步流程中的成功和失败情况。Promise 对象代表了一个最终可能会完成或失败的异步操作，并且一旦状态改变就不会再变回原来的状态。

**Promise 的基本概念**

一个 Promise 对象有三种状态：
1. **Pending（等待中）**：初始状态，既不成功也不失败。
2. **Fulfilled（已成功）**：表示异步操作成功完成。
3. **Rejected（已失败）**：表示异步操作失败。

一旦 Promise 变成 Fulfilled 或 Rejected 状态，它的状态就不会再改变，这种特性被称为“不可变性”。

**创建 Promise**

创建 Promise 实例的基本语法如下：

```javascript
const promise = new Promise((resolve, reject) => {
  // 异步操作
  if (/* 异步操作成功 */) {
    resolve(value); // 成功时调用 resolve 函数
  } else {
    reject(error); // 失败时调用 reject 函数
  }
});
```

`resolve` 和 `reject` 是 Promise 构造函数接收的执行器函数的参数。执行器函数会在 Promise 创建后立即执行。

**使用 Promise**

`.then()` 方法

`.then()` 方法用来注册成功回调函数。如果 Promise 成功，`.then()` 中的回调函数会被调用。

```javascript
promise.then(result => {
  console.log('成功: ', result);
});
```

`.catch()` 方法

`.catch()` 方法用来注册失败回调函数。如果 Promise 失败，`.catch()` 中的回调函数会被调用。

```javascript
promise.catch(error => {
  console.error('错误: ', error);
});
```

`.finally()` 方法

`.finally()` 方法无论 Promise 最终是成功还是失败都会执行。

```javascript
promise
  .then(result => {
    console.log('成功: ', result);
  })
  .catch(error => {
    console.error('错误: ', error);
  })
  .finally(() => {
    console.log('清理工作');
  });
```

**Promise 的链式调用**

Promise 支持链式调用，这意味着你可以连续地使用 `.then()`、`.catch()` 和 `.finally()` 方法来处理多个异步操作。

```javascript
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log('数据: ', data);
    return data.processed; // 假设 data 对象有一个 processed 属性
  })
  .then(processedData => {
    console.log('处理后的数据: ', processedData);
  })
  .catch(error => {
    console.error('请求错误: ', error);
  });
```

**Promise 的静态方法**

除了实例方法之外，Promise 类还提供了一些静态方法，用于处理多个 Promise：

- **`.all()`**：等待所有 Promise 完成，并返回一个包含所有结果的数组。
- **`.race()`**：返回一个 Promise，该 Promise 会解析或拒绝第一个完成的 Promise。
- **`.allSettled()`**：等待所有 Promise 完成，并返回一个对象数组，每个对象表示每个 Promise 的最终状态。
- **`.any()`**：返回一个 Promise，该 Promise 会在任何一个 Promise 成功时解析，或者在所有 Promise 都失败时拒绝。

这些静态方法可以非常方便地处理多个异步操作。

**示例**

下面是一个简单的示例，演示如何使用 Promise：

```javascript
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const randomValue = Math.random();
      if (randomValue > 0.5) {
        resolve(`Success: ${randomValue}`);
      } else {
        reject(new Error(`Error: ${randomValue}`));
      }
    }, 1000);
  });
};

fetchData()
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

以上就是一个关于 JavaScript 中 Promise 的简要介绍。Promise 提供了一种强大而灵活的方式来管理异步代码，使得程序更加易于理解和维护。

---

## JS代理

>**题号**：0007
>
>**来源**：OPPO
>
>**知识点**：JS的代理
>
>**时间**: 2024-07-28

请问一下JS 代码最终输出结果是（）

```js
const obj = {
    flag: 'Jhon',
    func: function(){
        console.log(this)
        console.log(this.flag)
    }
}
const p = new Proxy(obj,{})
p.func()
obj.func()
```

![](0007.png)

>**正确答案**:B
>
>**官方解析**:
>
>Proxy可以代理针对目标对象的访问，但它不是目标对象的透明代理，且在Proxy代理的情况下，目标对象内部的this关键字会指向Proxy代理，则p.func函数返回的this指向是Proxy，选项D错误。
>
>Proxy代理了对象obj，尽管this指向改变了，但是flag属性是保存在对象obj下，依然可以访问到目标对象obj下的flag属性，输出Jhon。当然，有些原生对象如Date的内部属性则可能因为this指向改变而无法取到值，选项A错误。
>
>Proxy代理后作用于变量p，原对象obj并没有受到影响，因此obj.func函数可以正常的输出this指向即自身、属性flag的值Jhon，选项C错误。
>
>所以代码最终的结果是Proxy {flag: 'Jhon', func: ƒ}、Jhon、{flag: 'Jhon', func: ƒ}、Jhon，选项B正确。

---

## 计算机网络香农公式

>**题号**：0008
>
>**来源**：OPPO
>
>**知识点**：计算机网络中的香农公式
>
>**时间**: 2024-07-28

现已知信噪比为30dB,信道带宽为8kHz,则该信道的信道容量大约为()

![](0008.png)

>**正确答案**:D
>
>**官方解析**:
>
>
>根据香农公式：![img](https://www.nowcoder.com/equation?tex=C%3DW*log2(1%2B%5Cfrac%7BS%7D%7BN%7D)(bit%2Fs))，W为信道带宽，单位为Hz，S是信号功率（瓦），N是噪声功率（瓦）。
>
>信噪比![img](https://www.nowcoder.com/equation?tex=SNR(%E4%BF%A1%E5%99%AA%E6%AF%94%EF%BC%8C%E5%8D%95%E4%BD%8D%E4%B8%BAdB)%3D10log10%5E%7B%5Cfrac%7BS%7D%7BN%7D%7D)，代入公式得![img](https://www.nowcoder.com/equation?tex=%5Cfrac%7BS%7D%7BN%7D%3D10%5E%7B%5Cfrac%7BSNR%7D%7B10%7D%7D%3D10%5E%7B%5Cfrac%7B30%7D%7B10%7D%7D%3D1000)，
>
>![img](https://www.nowcoder.com/equation?tex=C%3D8*1000*log2%5E%7B(1%2B1000)%7D%3D80000(bit%2Fs)%3D80000%2F1000%3D80kbps)

---

## 操作系统文件存储

>**题号**：0009
>
>**来源**：OPPO
>
>**知识点**：操作系统中的文件
>
>**时间**: 2024-07-28

如果一个磁盘块的大小是100字符,一文件中的第0到第99字符位于第5个磁盘块上,那么第280到300的字符位于第几号磁盘块上()

![](0009.png)

>**正确答案**:B
>
>**官方解析**:
>
>考查操作系统中的文件。
>
>一个磁盘块的大小是100字符，一文件中的第0到99的字符位于第5个磁盘块上，那么第280到300的字符位于![img](https://www.nowcoder.com/equation?tex=5%2B250%2F100%3D7)号磁盘块上

---

## JS严格模式，数组的arguments

>**题号**：0010
>
>**来源**：OPPO
>
>**知识点**：arguments对象,严格模式
>
>**时间**: 2024-07-28

![](0010.png)

>**正确答案**:C
>
>**官方解析**:
>
>在严格模式下，不论参数如何变化，arguments 对象都不会随之改变，因此严格模式下输出应为 true、false，选项 AD 错误。
>
>在非严格模式下，命名参数的变化会同步更新到 arguments 对象中，也就是说变量 a 的值与 arguments[0] 始终保持一致，输出应为 true、true，选项 B 错误。
>
>所以代码最终输出的结果分别为 true、false 和 true、true，选项 C 正确。

**arguments对象**

1. **`arguments` 对象**: `arguments` 是一个类数组对象，它包含了函数调用时传入的所有参数。在函数内部，可以通过 `arguments[0]` 来访问第一个参数。
2. **变量赋值**: 当你在一个函数内部声明一个变量并对其进行赋值时，这个变量的值只会影响这个局部变量本身。在非严格模式下，如果你在函数内部对一个未声明的变量进行赋值，它会被视为全局变量。在严格模式下，这样做会导致一个引用错误。

---

## 计算机网络UDP传输

>**题号**：0011
>
>**来源**：OPPO
>
>**知识点**：计算机网络中的UDP传输
>
>**时间**: 2024-07-28

UDP属于尽力而为的不可靠传输,使用UDP传输的数据,其可靠性需要在那一层保证?

![](0011.png)

>**答案**:D
>
>**官方解析**:
>
>UDP是一个无连接的、不可靠的传输层协议，如果用户采用UDP传输数据，必须在传输层的上层提供可靠性保证的工作，表示层只负责转化数据的表现形式，因此只能是应用层保证可靠性，选D。

---

## 计算机网络GBN协议

>**题号**：0012
>
>**来源**：OPPO
>
>**知识点**：可靠性传输的保证方法:停止等待,回退N帧,选择重传
>
>**时间**: 2024-07-28

主机A与主机B建立了一条TCP协议，采用的是GBN重传方式。假如发送窗口是3，在时刻t，接收方期待的下一个有序分组的序号是 k，请问这个时刻发送方窗口内的报文序号可能是多少？(假设接受主机不会对报文重新排序)

![](0012.png)

>**正确答案**:B
>
>**官方解析**:
>
>首先我们需要抓住关键--GBN协议，然后反应出GBN协议几个特点：发送方拥有一个窗口，长度为N=3；接收方无窗口，只接收希望接受序号的报文，对于失序到达的报文段采取的方式是直接丢弃；在重传的时候，将会重传当前发送方窗口中所有未被确认的报文段。在t时刻，接收方起到收到的下一个分组序号为k，说明接收方已经正确接受了k之前的所有分组，对于发送方而言，我们考虑两种最极端的情况：
>第一种情况：假设之前所有的报文都正确传输，没有任何丢失的问题，那么在这种情况下，发送方正确接收了接收方对于小于k的所有报文的ACK确认，因此窗口将会不断向后移动，序号为k、k+1、k+2；
>
>第二种情况：由已知条件我们可以得知序号为k-1的报文是发送方发送的最后一个报文，假设该报文虽然到达了接收方，但是接收方返回的ACK确认由于一些原因没有到达发送方，则窗口不会移动，在这种情况下我们再假设序号k-1位于窗口的最后一列，即如下图所示的所有序号报文都没有在发送方被确认，则得到了我们最坏的一种情况，k-3、k-2、k-1；
>
>综合上述两种情况，[k-3, k+2]区间内的都可能出现，因此选B。

---

## Linux命令home

>**题号**：0013
>
>**来源**：OPPO
>
>**知识点**：Linux命令
>
>**时间**: 2024-07-28

Linux 中，假设当前用户 zhangsan 所在目录为 /home，则想要切换到 zhangsan 的家目录 /home/zhangsan 下，则下面命令不能实现的是（）

![](0013.png)

>**正确答案**:B
>
>B选项中,cd /zhangsan 会去根目录下查早zhangsan故无法切换

---

## Linux命令basename

>**题号**：0014
>
>**来源**：OPPO
>
>**知识点**：Linux命令
>
>**时间**: 2024-07-28

Linux中,执行以下命令的结果是()

```bash
basename /etc/sysconfig/network
```

![](0014.png)

在 Linux 中，`basename` 命令用于从给定的路径中移除目录名，只返回文件名部分。当你运行 `basename /etc/sysconfig/network` 时，该命令将返回路径中的最后一部分，即文件名。

---

## 数据结构与算法：前中后缀表达式

>**题号**：0015
>
>**来源**：OPPO
>
>**知识点**：前中后缀表达式的转化
>
>**时间**: 2024-07-28

中缀表达式`a*b+c/d-e`的前缀表达式是:()

![](0015.png)

中缀表达式变为前缀表达式,将每一个运算都加上括号,然后将运算符移到自己的括号前面即可.

---

## 操作系统进程调度算法

>**题号**：0016
>
>**来源**：OPPO
>
>**知识点**：操作系统进程调度算法
>
>**时间**: 2024-07-29

下面哪种进程调度算法可能导致优先级进程饥饿：（）

![](0016.png)

## 编程题：进度环

>**题号**：0017
>
>**来源**：OPPO
>
>**知识点**：svg图像
>
>**时间**: 2024-07-29

实现一个进度环，当页面输入框中输入对应百分比，进度环动画展示当前百分比。效果如下图：

1. 在输入框中输入0-100的数据，点击更新进度按钮，圆环动画展示当前所占比例。
2. 当在输入框中输入数据超出0-100范围，不再继续往下运行函数，返回null

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      .progress-ring {
        width: 200px;
        height: 200px;
        position: relative;
      }
 
      .progress-ring .circle {
        fill: none;
        stroke: #ddd;
        stroke-width: 20;
      }
 
      .progress-ring .progress {
        fill: none;
        stroke: #0d7137;
        stroke-width: 20;
        stroke-dasharray: 0, 1000;
        stroke-linecap: round;
        transition: stroke-dasharray 0.5s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div class="progress-ring">
      <svg viewBox="0 0 100 100">
        <circle class="circle" cx="50" cy="50" r="40"></circle>
        <circle class="progress" cx="50" cy="50" r="40"></circle>
      </svg>
    </div>
    <input
      type="number"
      id="percentageInput"
      placeholder="输入百分比（0-100）"
    />
    <button onclick="updateProgress()">更新进度</button>
 
    <script>
      function updateProgress() {
        const percentageInput = document.getElementById('percentageInput')
        const percentage = parseInt(percentageInput.value, 10)
        /*--1. 补全代码，当输入的数据不是数字，或者超出【0,100】,当前函数返回null-----*/
        if (!percentage || percentage < 0 || percentage > 100) return null
 
        const progressRing = document.querySelector('.progress-ring')
        const progressCircle = progressRing.querySelector('.progress')
        const circumference = 2 * Math.PI * 40
 
        /*--2. 补全代码，根据输入的百分比设置圆环样式-----*/
        const offset = circumference*percentage/100
        progressCircle.style.strokeDasharray = `${offset} 1000`
      }
    </script>
  </body>
</html>
```

---

## 数据结构与算法:哈夫曼树

>**题号**：0018
>
>**来源**：OPPO
>
>**知识点**：哈夫曼树
>
>**时间**: 2024-07-29

若以{3, 6, 9, 12, 15, 18, 21, 24, 27}作为叶子结点的权值构造一棵哈夫曼树，则其带权路径长度是（ ）

![](0018.png)

画出哈夫曼树如下图:

![](哈夫曼树有背景.jpg)

由图像可知,该哈夫曼树的带权路径长度为

$27*2+(21+24+18+12+15)*3+9*4+(3+6)*5\\=54+270+36+45\\=405$

---

## 数据结构与算法:二分查找

>**题号**：0019
>
>**来源**：OPPO
>
>**知识点**：二分查找
>
>**时间**: 2024-08-15

已知一个有序表（2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26），当二分查找值为15的元素时，若采取向上取整的方式取中间值，查找成功的比较次数为（ ）

![](0019.png)

总共13个元素

- 第一次比较:`mid = (1+13)/2=7`,第7位是14,14<15
- 第二次比较`mid = (7+13)/2=10`,第10位是20,20>15
- 第三次比较`mid = (7+10)/2=8.5`,向上取整为9,第9位是18,18>15
- 第四次比较`mid = (7+9)/2=8`,第8位是16>15

此时若15存在,则应该在第7位和第8位之间,而实际上,他俩之间没有元素,故判断15不在数组中.

---

## CSS的Flex布局

>**题号**：0020
>
>**来源**：OPPO
>
>**知识点**：Flex布局
>
>**时间**: 2024-08-15

要实现一个左侧宽度固定,右侧元素自适应,应该在下面代码中补充哪个选项()

```html
<div class="container">
<div class="fixed-width">固定宽度</div>
<div class="flexible-width">自适应宽度</div>
</div>
.container {
display: flex;
}
.fixed-width {
width: 200px; /* 左边元素的固定宽度 */
}
.flexible-width {
/* 在此补全代码 */
}
```

![](0020.png)

---

>**题号**：0021
>
>**来源**：OPPO
>
>**知识点**：散列存储
>
>**时间**: 2024-07-28

## 数据结构与算法:散列(哈希)存储

已知一组关键字为 {21, 32, 43, 57, 61, 74, 85}，采用链地址法处理冲突，散列表是一个下标从0开始的长度为12的一维数组，散列函数为 H(key) = key MOD 12，则装填因子 α 是（）。

![](0021.png)

因为采用链地址法处理冲突,所以每一个关键字都会存储在散列表中,装填因子$\alpha = \frac{关键字数量}{散列表长度}=\frac{7}{12}$,存储情况如下图.

![](散列存储.png)

---

## 数据结构与算法:数组奇数

>**题号**：0022
>
>**来源**：OPPO
>
>**知识点**:数组的奇数
>
>**时间**: 2024-07-28

小欧有一个长度为 n*n* 的数组，现在他想挑出 3 个数，使得这 3 个数的和为奇数，如果可以挑出则输出 "YES"，否则输出 "NO"

```js
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;
 
void (async function () {   
    // Write your code here
    //获取数组长度
    let n = await readline();
    //获取整个数组
    let string = await readline();
    let array = string.split(" ").map((item) => parseInt(item));
    //如果只有3个数，则必须只有1个奇数，或者3个全为奇数
    if (n == 3) {
        let odd = 0;
        for (let i = 0; i < n; i++) {
            if (array[i] % 2 !== 0) {
                odd++;
            }
        }
        console.log(odd === 1 || odd === 3 ? "YES" : "NO");
    }
    //如果大于3个数，只要有1个奇数就可以
    else {
        let odd = 0;
        for (let i = 0; i < n; i++) {
            if (array[i] % 2 !== 0) {
                odd++;
                console.log("YES");
                break;
            }
        }
        if (!odd) console.log("NO");
    }
})();
```

---

## 数据结构与算法：子数组和
>**题号**：0023
>
>**来源**：OPPO
>
>**知识点**：子数组和的最大公约数
>
>**时间**: 2024-07-28

小欧有一个长度为 n*n* 的数组，他需要把这个数组分割成 k(k>1)*k*(*k*>1) 个非空子数组，也就是 [l1,r1],[l2,r2],⋯ ,[lk,rk][*l*1,*r*1],[*l*2,*r*2],⋯,[*l**k*,*r**k*]，其中 1≤l1<r1≤l2<r2≤⋯≤lk<rk≤n1≤*l*1<*r*1≤*l*2<*r*2≤⋯≤*l**k*<*r**k*≤*n*，并且 ri+1=li+1*r**i*+1=*l**i*+1。

对于每个子数组，小欧都会计算出这个子数组的总和 bi=ali+⋯+ari*b**i*=*a**l**i*+⋯+*a**r**i*。

现在小欧想找一个分割方案（子数组数量 k*k* 必须大于 1），使得 gcd⁡(b1,…,bk)gcd(*b*1,…,*b**k*) 最大，请你帮他找到最大值。

gcd：指最大公约数，Greatest Common Divisor的缩写。

暂时不会



# 58集团 23届秋招正式批

## 最短送餐路径

暂时不会

## 最长无重复子串

>**题号**：0002
>
>**来源**：58集团
>
>**知识点**：队列的应用
>
>**时间**: 2024-09-09

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 *
 * @param str string字符串
 * @return string字符串
 */
function filterMaxStr( str ) {
    // write code here
    let left = 0 	// 左指针
    let ans = '' 	// 返回结果
    let window = new Set() // 定义一个滑动窗口(队列),left到right指针的字符
    // 遍历字符串
    for(let right=0;right<str.length;right++){
        // 当窗口中已经有right指向的字符时
        // 则需要左移left将窗口缩小，直至字符移出窗口
        while(window.has(str[right])){
            window.delete(str[left++])
        }
        // 将right所指的字符加入窗口中
        window.add(str[right])
        // 如果当前子串长度超过上一次的子串，则取当前的
        if(right-left+1>ans.length){
            ans = str.slice(left,right+1)
        }
    }
    return ans
}
module.exports = {
    filterMaxStr : filterMaxStr
};
```

## 反转数组元素

>**题号**：0003
>
>**来源**：58集团
>
>**知识点**：反转数组，双指针，解构赋值
>
>**时间**: 2024-09-09

不要使用数组的reverse 方法，反转一下数组的元素。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 反转数组的字符串
 * @param s string字符串一维数组 字符串数组
 * @return string字符串一维数组
 */
function reverseString( s ) {
    // write code here
    let start = 0
    let end = s.length-1
    // 遍历交换
    while(start<end){
        // 解构赋值
        [s[start],s[end]]=[s[end],s[start]]
        // 指针移动
        start++
        end--
    }
    return s
}
module.exports = {
    reverseString : reverseString
};
```

## Cookie和Storage

>**题号**：0004
>
>**来源**：58集团
>
>**知识点**：Cookie和Storage
>
>**时间**: 2024-09-09

![](58集团0004.png)

>**题号**：0018
>
>**来源**：58集团
>
>**知识点**：Cookie和Storage
>
>**时间**: 2024-09-09

![](58集团0018.png)

## 移动端融合技术

>**题号**：0005
>
>**来源**：58集团
>
>**知识点**：PWA,severless,hybird app, ts,flutter
>
>**时间**: 2024-09-09

![](58集团0005.png)

## 箭头函数

>**题号**：0006
>
>**来源**：58集团
>
>**知识点**：箭头函数不能做构造函数
>
>**时间**: 2024-09-09

下段代码打印结果为：

```js
const Person = (name="wang",age=10) => {
  this.name = name;
  this.age = age;
  return this.name +' is '+ this.age + 'years old'
}
let result = new Person('zhang',11)
console.log(result)
```

![](58集团0006.png)

>**题号**：0020
>
>**来源**：58集团
>
>**知识点**：箭头函数,const变量声明,this指针上下文
>
>**时间**: 2024-09-09

以下输出结果

```js
const a = 10;
const obj = {
    a: 20,
    console: ()=>{
        var a = 30;
        console.log(this.a)
    }
}
obj.console()
```

![](58集团0020.png)

>**题号**：0023
>
>**来源**：58集团
>
>**知识点**：箭头函数,const变量声明,this指针上下文
>
>**时间**: 2024-09-09

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，以下差异说明错误的是：

![](58集团0023.png)



- 箭头函数没有独立的{%label this,arguments 和 super绑定 green%},并且不可被用作{%label 方法green%}
- 箭头函数不能用作{%label 构造函数 green%}.使用{%label new green%}调用它们会引发{%label TypeError green%}.它们也无法访问{%label new.target green%}关键字.
- 箭头函数不能在其主体中使用{%label yield green%},也不能作为生成器函数创建.
- 参数部分支持{%label 剩余参数,默认参数,解构赋值 green%},并且始终需要使用括号

```js
(a,b,...r) => expression
(a = 400, b = 20, c) => expression
([a,b] = [10,20]) => expression
({a,b}={a:10,b:20}) => expression
```

- 箭头函数可以是{%label async green%}的,方法就是在表达式前加上`async`关键字

```js
async param => expression
async (param1, param2, ...paramN) => {
    statements
}
```

- 当函数只有一个简单参数时,参数的括号可以省略.
- 当函数直接返回表达式时,函数体大括号和`return`关键字可以省略.
- 箭头函数总是未命名的.如果箭头函数需要调用自身,需要使用具名函数表达式.也可以将箭头函数赋值给一个变量,这样它就有了名字.

```js
const bob2 = a => a + 100
```

>**注意**
>
>当使用表达式体语法`(params)=>{object: literal}`返回对象字面量时,不能按预期工作

```js
const func = ()=>{foo: 1}
// 调用func()会返回undefined!

const func2 = ()=>{foo: function(){} }
// SyntaxError: function statement requires a name

const func3 =()=>{ foo(){}}
// SyntaxError: Unexpected token'{'
```

这是因为只有当箭头后面的标记不是左括号时,JS才会将箭头函数视为表达式体,因此括号({})内的代码会被解析为一系列语句,其中`foo`是{%label 标签 green%},而不是对象文字中的键.

要解决这个问题,可以用括号将对象字面量包装起来.

```js
const func = ()=>({foo: 1})
```

- 不能用作方法

箭头函数表达式只能用于非方法函数,因为它们没有自己的`this`.让我们看看将它们用作方法时会发生什么

```js
"use strict" 
const obj = {
    i: 10,
    b: ()=> console.log(this.i,this),
    c() {
        console.log(this.i,this)
    }
}

obj.b()		// 输出 undefined, Window{/* ... */}(或全局对象)
obj.c()		// 输出 10, Object {/* ... */}
```

另一个示例涉及到`Object.defineProperty()`

```js
"use strict"

const obj = {
    a: 10
}
Object.defineProperty(obj,"b",{
    get:()=>{
        console.log(this.a,typeof this.a,this)
        // undefined 'undefined' Window {/* ... */}
        return this.a + 10
        // 代表全局对象'Window',故'this.a'返回'undefined',this.a+10返回NaN
    }
})
```

由于{%label 类 green%}体具有`this`上下文,因此作为{%label 类字段 green%}的箭头函数会关闭类的`this`上下文,箭头函数体中的`this`将正确指向示例(对于静态字段来说就是类本身).但是,由于它是一个{%label  闭包  green%},而不是函数本身的绑定,因此`this`的值不会根据执行上下文而改变.

```js
class C {
    a = 1;
    autoBoundMethod=()=>{
        console.log(this.a)
    }
}
const c = new C()
c.autoBoundMethod()  // 1
const { autoBoundMethod } = c
autoBoundMethod()	// 1
// 如果这是普通方法,此时应该是undefined
```

箭头函数属性通常被称作"自动绑定方法",因为它与普通方法的等价性相同:

```js
// 这段代码暂时还不理解
class C {
    a = 1;
    constructor() {
        this.method = this.method.bind(this)
    }
    method() {
        console.log(this.a)
    }
}
```

{%label 以下内容暂时不理解  red%}

>备注
>
>类字段是在实例(instance)上定义的,而不是在原型(prototype)上定义的,因此每次创建实例都会创建一个新的函数引用并分配一个新的闭包,这可能会导致比普通非绑定方法更多的内存使用.

出于类似的原因,`call()`,`apply()`,`bind()`方法在箭头函数上调用时不起作用,因为箭头函数根据箭头函数定义的作用域来建立`this`的,而`this`的值不会根据函数的调用方式而改变.

- 没有参数绑定

箭头函数没有自己的`arguments`对象.因此,在本例中,`arguments`是对外层作用域参数的引用.

```js
function foo(n) {
    const f = ()=>arguments[0] + n; // foo的隐式参数绑定.arguments[0]为n
    return f();
}

foo(3) // 3 + 3 = 6
```

>**注意**
>
>严格模式下不能声明名为`arguments`的变量,因此上面的代码会出现语法错误.这使得`arguments`的范围效应更容易理解.

在大多数情况下,使用{%label 剩余参数 green%}是比使用`arguments`对象更好的选择.

```js
function foo(n) {
    const f = (...args)=>args[0]+n
    return f(10)
}

foo(1)  // 11
```

- 不能用作构造函数

箭头函数不能用作构造函数,当使用`new`调用时会出错.它们也没有`prototype`属性.

```js
const Foo = () =>{}
const foo = new Foo() // TypeError: Foo is not a constructor
console.log("prototype" in Foo) //false
```

- 不能用作生成器

箭头函数的主体中不能使用`yield`关键字(除非在箭头函数进一步嵌套的生成器函数中使用).

因此,箭头函数不能用作生成器.

- 箭头前换行

箭头函数的参数和箭头之间不能换行

```js
const func = (a,b,c)
	=> 1
// SyntaxError: Unexpected token '=>'
```

为便于格式化,可在箭头后换行,或在函数体周围使用括号/花括号,如下图所示.也可以在参数之间换行.

```js
const func = (a, b, c) =>
  1;

const func2 = (a, b, c) => (
  1
);

const func3 = (a, b, c) => {
  return 1;
};

const func4 = (
  a,
  b,
  c,
) => 1;
```

- 箭头的优先级

虽然箭头函数中的箭头不是运算符,但与普通函数相比,箭头函数具有特殊的解析规则,与运算符优先级的交互方式不同.

{%label 这是错误示范 red%}

```js
let callback;
callback = callback || ()=>{}
// SyntaxError: invalid arrow-function arguments
```

由于`=>`的优先级低于大多数运算符,因此需要使用括号来避免`callback || ()`被解析为箭头函数的参数列表

{%label 以下是正确内容 green%}

```js
callback = callback || (()=>{})
```



## HTTP报文头字段

以下与http缓存无关的头字段是:

![](58集团0007.png)

常用HTTP标头

- Content-Length

  - 类型: Forbidden header name(禁止修改的标头)
  - 语法 :`Content-Length:  <length>`
  - 指令: `<length>`消息的长度,用十进制数字表示的字节的数目

- ETag

  - `Etag`HTTP响应头是资源的特定版本的标识符.这可以让缓存更高效,并节省带宽,因为如果内容没有改变,Web服务器不需要发送完整的响应.而如果内容发生了变化,使用Etag有助于防止资源的同时更新相互覆盖('空中碰撞')
  - 如果给定URL中的资源更改,则一定要生成新的`ETag`值.比较这些`Etag`能快速确定此资源是否变化.
  - 类型: Forbidden header name
  - 语法: 

  ```http
  ETag: W/"<etag_value>"
  ETag: "<etag_value>"
  ```

  

  

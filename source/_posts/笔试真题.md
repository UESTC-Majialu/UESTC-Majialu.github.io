---
title: 笔试真题
date: 2024-07-25 16:27:53
tags: 刷题
categories: 刷题笔记
top_img: 顶部图.jpg
cover: 缩略图.jpg
---

>**题号**：0001
>
>**来源**：OPPO
>
>**知识点**：css权重分析
>
>**时间**: 2024-07-25

执行以下程序，对于①②式能否在a标签上实现效果，下列说法正确的是（）

```html
div {

        width:200px;

        height: 200px;

        text-decoration: none; ...①

        font-size:12px; ...②

}

<div class="father">

      <a href = "#">跳转</a>

</div>
```

![](0001.png)

>**正确答案**:D
>
>**官方题解**:
>
>text-decoration和font-size都是定义在a的父级元素上，通过让a元素继承这两个属性来实现效果。事实上，这两个属性都是可继承的，但不同的是，a标签自身还有默认属性text-decoration和color，该默认样式的权重比继承的高（继承的权重为0），因此①式并没有在a标签上起效果，而a标签的默认样式属性中没有font-size，因此②式可以起效果。



在CSS中，元素的样式可以被多个规则所影响。当这些规则发生冲突时，浏览器需要决定哪个规则应该优先应用。这就涉及到CSS中的“权重”（或称为“特异性”）概念。

**CSS权重的基本原则**

CSS权重是根据选择器的不同类型来计算的，权重值越高，则该选择器的优先级越高。权重由高到低分为四个等级：

1. **内联样式** (`style` 属性)：权重为 1000。

   - 例如：`<p style="color: red;">This text is red.</p>`

2. **标识符选择器** (`#id`)：每个标识符选择器权重为 100。

   - 例如：`#myID { color: blue; }`

3. **类选择器** (`.class`)、属性选择器 (`[attribute]`) 和伪类 (`:hover`, `:first-child` 等)：每个类选择器、属性选择器或伪类的权重为 10。

   - 例如：

     ```
     .myClass { color: green; }
     ```

     - 或者：`a:hover { color: yellow; }`

4. **类型选择器** (`element`) 和伪元素 (`::before`, `::after` 等)：每个类型选择器或伪元素的权重为 1。

   - 例如：

     ```
     p { color: orange; }
     ```

     - 或者：`p::first-letter { color: purple; }`

5. **通用选择器** (`*`, `div`, `p` 等)、子代选择器 (`>`), 相邻同胞选择器 (`+`), 一般同胞选择器 (`~`) 和伪关键字 `:not()` 的权重为 0。

   - 例如：

     ```
     * { color: black; }
     ```

     - 或者：`div > p { color: gray; }`

6. **继承** 和 **用户代理样式表** 的权重为 0，但它们具有默认优先级。

   - 浏览器默认的样式。

7. **`!important` 标志**：在样式声明后加上 `!important` 可以提高权重，其权重高于所有其他权重，但低于内联样式中的 `!important`。

   - 例如：`p { color: blue !important; }`

**计算权重的步骤**

- 对于一个给定的选择器，计算每个级别的权重总和。
- 如果两个选择器的权重相同，则离元素更近的选择器优先（更具体的上下文）。
- 如果权重仍然相同，最后声明的规则将优先（CSS的层叠规则）。

**示例**

假设我们有以下CSS规则：

1. `p { color: blue; }` （权重为 1）
2. `.redText { color: red; }` （权重为 10）
3. `#special { color: green; }` （权重为 100）

如果一个段落同时使用了类 `.redText` 和 ID `#special`，那么最终的颜色将是绿色，因为 ID 选择器的权重更高。

**复杂选择器**

当选择器包含多个部分时，将每个部分的权重相加。例如，`#myID .myClass` 的权重为 100 + 10 = 110。

**总结**

理解CSS权重可以帮助你更好地控制页面样式的优先级，避免不必要的覆盖和冲突。尽量避免过度使用高权重的选择器（如 `!important`），因为它可能会导致样式难以管理和维护。

---

>**题号**：0002
>
>**来源**：OPPO
>
>**知识点**：行内元素和块级元素
>
>**时间**: 2024-07-25

![](0002.png)

>**正确答案**:B
>
>**官方解析**:vertical-align在行内元素中设置有效，在块级元素中设置无效，即使块级元素嵌套了行内元素，行内元素也不会继承块级元素的该属性，故B选项符合要求；ACD选项均在块级元素中设置有效，作用在块级元素内的文本等内容。

---

>**题号**:0003
>
>**来源**:OPPO
>
>**知识点**:BFC
>
>**时间**：2024-07-28

执行一下程序，当给main盒子添加overflow:hidden；则变化情况为

```html
<style>
.box {
        width: 200px;
        height: 300px;
}
.sideBar {
        float: left;
        width: 50px;
        height: 100px;
}
.main {
        height: 200px;
}
</style>
<div class="box">
        <div class="sideBar"></div>
        <div class="main"></div>
</div>
```

![](0003.png)

>**正确答案**:B
>
>**官方解析**:
>
>添加前，由于sideBar盒子设置了浮动，因此main盒子会移动并占据sideBar盒子的位置，结果是main盒子紧贴在sideBar盒子的左边，添加后，overflow:hidden触发产生新的bfc。根据bfc的布局规则，bfc区域不会与浮动元素的区域发生重叠，因此，main盒子会紧贴在sideBar盒子的右边。

**常规流,块盒**

1. 水平方向上,撑满整个包含块宽度,垂直方向上,依次摆放
2. 垂直方向上相邻的元素,margin会合并(取两者中的最大值)
3. 父子关系的情况下,可能会产生margin塌陷
4. 父子关系的情况下,父元素无视浮动元素会产生高度坍塌
5. 兄弟关系的情况下,正常元素可能会被浮动元素覆盖(正常元素在浮动元素之后)

**BFC**(Block Formatting Context)区块格式化上下文

1. 开启BFC的区域,是一块{%label 独立的渲染区域 green%}
2. {%label 隔绝了内部与外部的联系 green%},内部渲染不会影响到外部
3. 不同的BFC区域,{%label 渲染时也互不干扰 green%}

**开启BFC能解决什么问题**

1. 开启BFC，其{%label 子元素 green%}不会再产生margin塌陷问题(不会和他的子元素产生margin合并)
2. 开启BFC，就算子元素浮动，{%label 自身高度也不会坍塌 green%}(计算高度时不再无视浮动元素)
3. 开启BFC，{%label 自己不会被其他浮动元素所覆盖 green%}(不会与浮动元素重叠，会避开浮动元素排布)

**如何开启BFC**

1. 根元素(HTML)自身是一个BFC
2. 设置{%label float green%}属性
3. 设置{%label position green%}属性为设置{%label absolute或fixed green%}
4. 设置{%label overflow green%}属性值{%label 不为visible green%}
5. 行内块盒({%label inline-block green%})
6. 设置{%label display green%}为{%label flow-root green%}的元素
7. 伸缩项目({%label flex盒子内的item green%})
8. 多列容器(设置{%label column-count green%})
9. 表格元素(table thead tbody tfoot tr th td caption)
10. column-span为all的元素(表格第一行横跨所有列)

---

>**题号**:0004
>
>**来源**:OPPO
>
>**知识点**: JS的逻辑与和逻辑或
>
>**时间**：2024-07-28

此代码的运行结果为

```js
console.log(0&&1,0||1,1&&3,1||3)
```

![](0004.png)

>**正确答案**:A
>
>**官方解析**:
>
>再进行&&和||运算时，两边的语句会转化为布尔类型（Boolean），然后再进行运算，本题中，
>
>&&和||两边均为数字，非0数字转化为true，0转化为false。
>
>&&是两边都是true，结果才是true；||是任意有一个true结果就为true。
>
>第一个表达式结果为false，返回0。
>
>第二个表达式结果为true，返回1，D选项排除。
>
>第三个表达式为true，因为&&需判断两个值都true，所以返回第二个为真的值3，C选项错误。
>
>第四个表达式为true，因为||只判断一个值为true就是true，所以返回第一个为真的值1。
>
>A选项是正确的。

对于JS的逻辑与(&&)和逻辑或(||),如果两边均为数字,则非0数字为true,0为false

$逻辑运算\begin{cases}\&\&\begin{cases}第一位为0->返回0\\第一位为true\begin{cases}第二位为0->返回0\\第二位为true->返回第二位的值\end{cases}\end{cases}\\逻辑或\begin{cases}第一位为0->返回第二位\\第一位为true->返回第一位\end{cases}\end{cases}$

---

>**题号**：0005
>
>**来源**：OPPO
>
>**知识点**：循环结构
>
>**时间**: 2024-07-28

此代码的运行结果为()

```js
var arr = [1,2,5,7,8]
for(var i=0;i<arr.length;i++){
    for(var j=0;j<arr.length;j++){
        if(arr[i]+arr[j] == 12){
            console.log(i,j)
        }
    }
}
```

![](0005.png)

>**正确答案**:D
>
>**官方解析**:
>
>此代码用双重for循环遍历数组，当两个元素的和为12时，将两个元素的下标输出。
>
>从数组中可知，5+7的和为12。 因为是双重for循环，第一层循环到5第二层循环到7时，会执行if语句块，第一层循环到7第二层循环到5时，也会执行if语句，所以会输出两次，AB选项排除。
>
>if 语句块中输出的变量i , j 分别可看做数组元素的下标，所以输出的值应为2 3；3 2，D选项正确。

---

>**题号**：0006
>
>**来源**：OPPO
>
>**知识点**：JS的Promise
>
>**时间**: 2024-07-28

请问一下JS代码输出的结果是()

```js
const p1 = Promise.resolve(117)
const p2 = Promise.resolve(p1)
const p3 = Promise.resolve(117)
console.log(p1==p2,p1===p2,p1===p3)
```

![](0006.png)

>**正确答案**:A
>
>**官方解析**:
>
>Promise.resolve方法如果传入一个非Promise、非thenable的立即值，则得到的是以这个值填充的Promise，即使这个值一样，得到的也不是相同的Promise，所以p1不等于p3，选项BC错误。
>
>Promise.resolve方法如果传入一个真正的Promise，那么返回的就是这个Promise本身，所以p1和p2是同一个Promise，选项D错误。
>
>所以最终输出的结果是true、true、false，选项A正确。

**什么是Promise**

- Promise A+规范:
  - 出现在ES6(2015年)之前
  - 是一个民间规范
  - 主要解决异步处理问题
  - 该规范解释Promise对象为:带有then方法的对象
  - 规定了一个带then方法的对象到底满足什么规则才能进行异步处理
- ES6的Promise
  - 吸纳了Promise A+ 规范
  - 可以使用构造函数方法`const p = new Promise()`来得到一个符合Promise A+ 规范的对象
  - 引入了一些新的方法
    - catch
    - finally
    - all
    - race
    - allsettled 

**GPT整理内容**

JavaScript 中的 `Promise` 是一种处理异步操作的方式，它提供了一种比传统的回调函数更优雅的方式来处理异步流程中的成功和失败情况。Promise 对象代表了一个最终可能会完成或失败的异步操作，并且一旦状态改变就不会再变回原来的状态。

**Promise 的基本概念**

一个 Promise 对象有三种状态：
1. **Pending（等待中）**：初始状态，既不成功也不失败。
2. **Fulfilled（已成功）**：表示异步操作成功完成。
3. **Rejected（已失败）**：表示异步操作失败。

一旦 Promise 变成 Fulfilled 或 Rejected 状态，它的状态就不会再改变，这种特性被称为“不可变性”。

**创建 Promise**

创建 Promise 实例的基本语法如下：

```javascript
const promise = new Promise((resolve, reject) => {
  // 异步操作
  if (/* 异步操作成功 */) {
    resolve(value); // 成功时调用 resolve 函数
  } else {
    reject(error); // 失败时调用 reject 函数
  }
});
```

`resolve` 和 `reject` 是 Promise 构造函数接收的执行器函数的参数。执行器函数会在 Promise 创建后立即执行。

**使用 Promise**

`.then()` 方法

`.then()` 方法用来注册成功回调函数。如果 Promise 成功，`.then()` 中的回调函数会被调用。

```javascript
promise.then(result => {
  console.log('成功: ', result);
});
```

`.catch()` 方法

`.catch()` 方法用来注册失败回调函数。如果 Promise 失败，`.catch()` 中的回调函数会被调用。

```javascript
promise.catch(error => {
  console.error('错误: ', error);
});
```

`.finally()` 方法

`.finally()` 方法无论 Promise 最终是成功还是失败都会执行。

```javascript
promise
  .then(result => {
    console.log('成功: ', result);
  })
  .catch(error => {
    console.error('错误: ', error);
  })
  .finally(() => {
    console.log('清理工作');
  });
```

**Promise 的链式调用**

Promise 支持链式调用，这意味着你可以连续地使用 `.then()`、`.catch()` 和 `.finally()` 方法来处理多个异步操作。

```javascript
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log('数据: ', data);
    return data.processed; // 假设 data 对象有一个 processed 属性
  })
  .then(processedData => {
    console.log('处理后的数据: ', processedData);
  })
  .catch(error => {
    console.error('请求错误: ', error);
  });
```

**Promise 的静态方法**

除了实例方法之外，Promise 类还提供了一些静态方法，用于处理多个 Promise：

- **`.all()`**：等待所有 Promise 完成，并返回一个包含所有结果的数组。
- **`.race()`**：返回一个 Promise，该 Promise 会解析或拒绝第一个完成的 Promise。
- **`.allSettled()`**：等待所有 Promise 完成，并返回一个对象数组，每个对象表示每个 Promise 的最终状态。
- **`.any()`**：返回一个 Promise，该 Promise 会在任何一个 Promise 成功时解析，或者在所有 Promise 都失败时拒绝。

这些静态方法可以非常方便地处理多个异步操作。

**示例**

下面是一个简单的示例，演示如何使用 Promise：

```javascript
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const randomValue = Math.random();
      if (randomValue > 0.5) {
        resolve(`Success: ${randomValue}`);
      } else {
        reject(new Error(`Error: ${randomValue}`));
      }
    }, 1000);
  });
};

fetchData()
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

以上就是一个关于 JavaScript 中 Promise 的简要介绍。Promise 提供了一种强大而灵活的方式来管理异步代码，使得程序更加易于理解和维护。

---

>**题号**：0007
>
>**来源**：OPPO
>
>**知识点**：JS的代理
>
>**时间**: 2024-07-28

请问一下JS 代码最终输出结果是（）

```js
const obj = {
    flag: 'Jhon',
    func: function(){
        console.log(this)
        console.log(this.flag)
    }
}
const p = new Proxy(obj,{})
p.func()
obj.func()
```

![](0007.png)

>**正确答案**:B
>
>**官方解析**:
>
>Proxy可以代理针对目标对象的访问，但它不是目标对象的透明代理，且在Proxy代理的情况下，目标对象内部的this关键字会指向Proxy代理，则p.func函数返回的this指向是Proxy，选项D错误。
>
>Proxy代理了对象obj，尽管this指向改变了，但是flag属性是保存在对象obj下，依然可以访问到目标对象obj下的flag属性，输出Jhon。当然，有些原生对象如Date的内部属性则可能因为this指向改变而无法取到值，选项A错误。
>
>Proxy代理后作用于变量p，原对象obj并没有受到影响，因此obj.func函数可以正常的输出this指向即自身、属性flag的值Jhon，选项C错误。
>
>所以代码最终的结果是Proxy {flag: 'Jhon', func: ƒ}、Jhon、{flag: 'Jhon', func: ƒ}、Jhon，选项B正确。

---

>**题号**：0008
>
>**来源**：OPPO
>
>**知识点**：计算机网络中的香农公式
>
>**时间**: 2024-07-28

现已知信噪比为30dB,信道带宽为8kHz,则该信道的信道容量大约为()

![](0008.png)

>**正确答案**:D
>
>**官方解析**:
>
>
>根据香农公式：![img](https://www.nowcoder.com/equation?tex=C%3DW*log2(1%2B%5Cfrac%7BS%7D%7BN%7D)(bit%2Fs))，W为信道带宽，单位为Hz，S是信号功率（瓦），N是噪声功率（瓦）。
>
>信噪比![img](https://www.nowcoder.com/equation?tex=SNR(%E4%BF%A1%E5%99%AA%E6%AF%94%EF%BC%8C%E5%8D%95%E4%BD%8D%E4%B8%BAdB)%3D10log10%5E%7B%5Cfrac%7BS%7D%7BN%7D%7D)，代入公式得![img](https://www.nowcoder.com/equation?tex=%5Cfrac%7BS%7D%7BN%7D%3D10%5E%7B%5Cfrac%7BSNR%7D%7B10%7D%7D%3D10%5E%7B%5Cfrac%7B30%7D%7B10%7D%7D%3D1000)，
>
>![img](https://www.nowcoder.com/equation?tex=C%3D8*1000*log2%5E%7B(1%2B1000)%7D%3D80000(bit%2Fs)%3D80000%2F1000%3D80kbps)

---

>**题号**：0009
>
>**来源**：OPPO
>
>**知识点**：操作系统中的文件
>
>**时间**: 2024-07-28

如果一个磁盘块的大小是100字符,一文件中的第0到第99字符位于第5个磁盘块上,那么第280到300的字符位于第几号磁盘块上()

![](0009.png)

>**正确答案**:B
>
>**官方解析**:
>
>考查操作系统中的文件。
>
>一个磁盘块的大小是100字符，一文件中的第0到99的字符位于第5个磁盘块上，那么第280到300的字符位于![img](https://www.nowcoder.com/equation?tex=5%2B250%2F100%3D7)号磁盘块上

---

>**题号**：0010
>
>**来源**：OPPO
>
>**知识点**：arguments对象,严格模式
>
>**时间**: 2024-07-28

![](0010.png)

>**正确答案**:C
>
>**官方解析**:
>
>在严格模式下，不论参数如何变化，arguments 对象都不会随之改变，因此严格模式下输出应为 true、false，选项 AD 错误。
>
>在非严格模式下，命名参数的变化会同步更新到 arguments 对象中，也就是说变量 a 的值与 arguments[0] 始终保持一致，输出应为 true、true，选项 B 错误。
>
>所以代码最终输出的结果分别为 true、false 和 true、true，选项 C 正确。

**arguments对象**

1. **`arguments` 对象**: `arguments` 是一个类数组对象，它包含了函数调用时传入的所有参数。在函数内部，可以通过 `arguments[0]` 来访问第一个参数。
2. **变量赋值**: 当你在一个函数内部声明一个变量并对其进行赋值时，这个变量的值只会影响这个局部变量本身。在非严格模式下，如果你在函数内部对一个未声明的变量进行赋值，它会被视为全局变量。在严格模式下，这样做会导致一个引用错误。

---

>**题号**：0011
>
>**来源**：OPPO
>
>**知识点**：计算机网络中的UDP传输
>
>**时间**: 2024-07-28

UDP属于尽力而为的不可靠传输,使用UDP传输的数据,其可靠性需要在那一层保证?

![](0011.png)

>**答案**:D
>
>**官方解析**:
>
>UDP是一个无连接的、不可靠的传输层协议，如果用户采用UDP传输数据，必须在传输层的上层提供可靠性保证的工作，表示层只负责转化数据的表现形式，因此只能是应用层保证可靠性，选D。

---

>**题号**：0012
>
>**来源**：OPPO
>
>**知识点**：可靠性传输的保证方法:停止等待,回退N帧,选择重传
>
>**时间**: 2024-07-28

主机A与主机B建立了一条TCP协议，采用的是GBN重传方式。假如发送窗口是3，在时刻t，接收方期待的下一个有序分组的序号是 k，请问这个时刻发送方窗口内的报文序号可能是多少？(假设接受主机不会对报文重新排序)

![](0012.png)

>**正确答案**:B
>
>**官方解析**:
>
>首先我们需要抓住关键--GBN协议，然后反应出GBN协议几个特点：发送方拥有一个窗口，长度为N=3；接收方无窗口，只接收希望接受序号的报文，对于失序到达的报文段采取的方式是直接丢弃；在重传的时候，将会重传当前发送方窗口中所有未被确认的报文段。在t时刻，接收方起到收到的下一个分组序号为k，说明接收方已经正确接受了k之前的所有分组，对于发送方而言，我们考虑两种最极端的情况：
>第一种情况：假设之前所有的报文都正确传输，没有任何丢失的问题，那么在这种情况下，发送方正确接收了接收方对于小于k的所有报文的ACK确认，因此窗口将会不断向后移动，序号为k、k+1、k+2；
>
>第二种情况：由已知条件我们可以得知序号为k-1的报文是发送方发送的最后一个报文，假设该报文虽然到达了接收方，但是接收方返回的ACK确认由于一些原因没有到达发送方，则窗口不会移动，在这种情况下我们再假设序号k-1位于窗口的最后一列，即如下图所示的所有序号报文都没有在发送方被确认，则得到了我们最坏的一种情况，k-3、k-2、k-1；
>
>综合上述两种情况，[k-3, k+2]区间内的都可能出现，因此选B。

---

>**题号**：0013
>
>**来源**：OPPO
>
>**知识点**：Linux命令
>
>**时间**: 2024-07-28

Linux 中，假设当前用户 zhangsan 所在目录为 /home，则想要切换到 zhangsan 的家目录 /home/zhangsan 下，则下面命令不能实现的是（）

![](0013.png)

>**正确答案**:B
>
>B选项中,cd /zhangsan 会去根目录下查早zhangsan故无法切换

---

>**题号**：0014
>
>**来源**：OPPO
>
>**知识点**：Linux命令
>
>**时间**: 2024-07-28

Linux中,执行以下命令的结果是()

```bash
basename /etc/sysconfig/network
```

![](0014.png)

在 Linux 中，`basename` 命令用于从给定的路径中移除目录名，只返回文件名部分。当你运行 `basename /etc/sysconfig/network` 时，该命令将返回路径中的最后一部分，即文件名。

---

>**题号**：0015
>
>**来源**：OPPO
>
>**知识点**：前中后缀表达式的转化
>
>**时间**: 2024-07-28

中缀表达式`a*b+c/d-e`的前缀表达式是:()

![](0015.png)

中缀表达式变为前缀表达式,将每一个运算都加上括号,然后将运算符移到自己的括号前面即可.

---

>**题号**：0016
>
>**来源**：OPPO
>
>**知识点**：操作系统进程调度算法
>
>**时间**: 2024-07-29

下面哪种进程调度算法可能导致优先级进程饥饿：（）

![](0016.png)
